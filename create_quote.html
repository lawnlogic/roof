<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap" rel="stylesheet">

  <title>Lawn Area Calculator</title>
  <link rel="stylesheet" href="styles.css">
  <script src="header.js" defer></script>

  <!-- Leaflet + Draw -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <!-- Turf.js -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
</head>

<body>
  <div class="create-quote-container">
    <h2>Lawn Area Calculator</h2>
    <div class="input-group">
      <label for="address">NZ Address:</label>
      <input type="text" id="address" placeholder="Start typing an address..." autocomplete="off" />
    </div>
    <div id="address-suggestions" class="suggestions hidden"></div>
    <button id="lookup-btn" class="action-button">Calculate Lawn Area</button>
    <div id="result" class="result hidden">
      <div id="address-display"></div>
      <div id="area"></div>
      <div id="time"></div>
    </div>
    <div id="error" class="error hidden"></div>

    <!-- map -->
    <div id="aerial-container" class="hidden" style="margin-top: 40px;">
      <h2 style="margin-bottom: 15px;">Aerial View & Lawn Measurement</h2>

      <p style="margin: 0 0 15px 0; font-weight: 500; color: white; text-align: center;">
        Edit the map to exclude everything that will not be mowed (buildings, driveways, gardens, etc.)
      </p>

      <div id="aerial-map" style="width:100%; height:500px; border:2px solid #ccc; border-radius:8px;"></div>
      
      <!-- Control buttons -->
      <div class="map-controls" style="margin-top: 15px; text-align: center; padding: 20px 0; background: rgba(0,0,0,0.6);">
        <button id="btn-new-shape" class="action-button" style="min-width: 100px;">
          New Area
        </button>
        <button id="btn-edit-shapes" class="action-button secondary" style="min-width: 100px;">
          Edit Areas
        </button>
        <button id="btn-finish-editing" class="action-button" style="min-width: 100px; background: #28a745; color: white;">
          Finish
        </button>
      </div>

    <!-- Professional Job Summary Box -->
    <div id="pricing-box" class="pricing-box hidden">
      <div class="input-group">
        <label for="rate-input">Base Rate per m² (ex GST):</label>
        <input type="number" id="rate-input" value="0.20" step="0.05" min="0" />
      </div>
      <div class="input-group">
        <label for="callout-input">Call-out / Travel Fee (ex GST):</label>
        <input type="number" id="callout-input" value="80" step="10" min="0" />
      </div>

      <!-- Difficulty Multiplier -->
      <div class="slider-container">
        <div class="slider-label">
          <span>Job Difficulty Multiplier</span>
          <span id="difficulty-value">1.0x</span>
        </div>
        <input type="range" id="difficulty-slider" min="1.0" max="2.0" step="0.1" value="1.0" />
      </div>

      <!-- Catch & Mulch -->
      <div class="checkbox-group">
        <label for="catch-mulch">Catch & Mulch Service (+$40 ex GST)</label>
        <input type="checkbox" id="catch-mulch" />
      </div>

      <div class="input-group">
        <label for="estimated-hours">Estimated Time (hours):</label>
        <input type="number" id="estimated-hours" value="1.0" step="0.25" min="0.25" />
      </div>
      <div class="input-group">
        <label for="hourly-rate">Your Hourly Cost (fuel, labour, etc.):</label>
        <input type="number" id="hourly-rate" value="50" step="5" min="0" />
      </div>

      <!-- Collapsible Client Details -->
      <div class="collapsible-header" id="client-toggle">
        Client Details (optional) <span>▼</span>
      </div>
      <div class="collapsible-content" id="client-form">
        <div class="input-group">
          <label for="client-first">First Name</label>
          <input type="text" id="client-first" placeholder="John" />
        </div>
        <div class="input-group">
          <label for="client-last">Last Name</label>
          <input type="text" id="client-last" placeholder="Doe" />
        </div>
        <div class="input-group">
          <label for="client-email">Email</label>
          <input type="email" id="client-email" placeholder="john@example.com" />
        </div>
        <div class="input-group">
          <label for="client-phone">Phone</label>
          <input type="tel" id="client-phone" placeholder="021 123 4567" />
        </div>
      </div>

      <div class="pricing-row">
        <span>Lawn Area:</span>
        <span id="final-area">0 m²</span>
      </div>
      <div class="pricing-row">
        <span>Mowing Revenue (ex GST):</span>
        <strong id="mowing-revenue">$0.00</strong>
      </div>
      <div class="pricing-row">
        <span>Total Revenue (ex GST):</span>
        <strong id="total-revenue">$0.00</strong>
      </div>
      <div class="pricing-row">
        <span>GST (15%):</span>
        <strong id="gst">$0.00</strong>
      </div>
      <div class="pricing-row">
        <span>TOTAL (incl GST):</span>
        <strong id="total-incl">$0.00</strong>
      </div>
      <div class="summary-box">
        <div class="summary-row">
          <span>Estimated Cost (time × hourly):</span>
          <strong id="est-cost">$0.00</strong>
        </div>
        <div class="summary-row">
          <span>Estimated Profit (ex GST):</span>
          <strong id="est-profit">$0.00</strong>
        </div>
        <div class="summary-row total">
          <span>Profit per Hour:</span>
          <strong id="profit-hour">$0.00</strong>
        </div>
      </div>
      <button id="generate-pdf-btn">Generate Quote Link</button>
      <div id="quote-link-box" class="hidden">
        Share this quote with your client:<br>
        <a id="quote-link" href="#" target="_blank"></a>
      </div>
    </div>
  </div>

  <script type="module">
    // Prevent adding vertex on touchstart → drag (common mobile bug)
    if (L.Draw && L.Draw.Polyline) {
        L.Draw.Polyline.include({
            _onTouch: function (e) {
                // Only add vertex on real tap/click, not on beginning of drag
                if (e.type === 'touchstart') {
                    this._touchStartTime = Date.now();
                    return;
                }
                
                if (e.type === 'touchend' || e.type === 'touchcancel') {
                    const duration = Date.now() - (this._touchStartTime || 0);
                    if (duration < 250) {  // short tap → accept as click
                        L.Draw.Polyline.prototype._onTouchOriginal.call(this, e);
                    }
                    this._touchStartTime = null;
                }
            }
        });

        // Backup original if you ever want to restore
        if (!L.Draw.Polyline.prototype._onTouchOriginal) {
            L.Draw.Polyline.prototype._onTouchOriginal = L.Draw.Polyline.prototype._onTouch;
            L.Draw.Polyline.prototype._onTouch = L.Draw.Polyline.prototype._onTouch; // overridden above
        }
    }
    // ────────────────────────────────────────────────

    const firebaseConfig = {
      apiKey: "AIzaSyAzS6a2JbgFxSJLPi2-sWyflOfrE7jd73g",
      authDomain: "deep-edge-cc5bd.firebaseapp.com",
      projectId: "deep-edge-cc5bd",
      storageBucket: "deep-edge-cc5bd.firebasestorage.app",
      messagingSenderId: "23198790796",
      appId: "1:23198790796:web:616de764b8a8db2ae1f7a9",
      measurementId: "G-GLYGPCHRXM"
    };
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = 'login.html';
        return;
      }
    });

    const WORKER_URL = "https://firebase-protected-backend.jamesisarad.workers.dev";

    const btn = document.getElementById('lookup-btn');
    const addressInput = document.getElementById('address');
    const resultDiv = document.getElementById('result');
    const errorDiv = document.getElementById('error');
    const addressDisplay = document.getElementById('address-display');
    const areaDisplay = document.getElementById('area');
    const timeDisplay = document.getElementById('time');
    const aerialContainer = document.getElementById('aerial-container');
    const pricingBox = document.getElementById('pricing-box');
    const rateInput = document.getElementById('rate-input');
    const calloutInput = document.getElementById('callout-input');
    const estimatedHoursInput = document.getElementById('estimated-hours');
    const hourlyRateInput = document.getElementById('hourly-rate');
    const finalAreaDisplay = document.getElementById('final-area');

    const difficultySlider = document.getElementById('difficulty-slider');
    const difficultyValue = document.getElementById('difficulty-value');
    const catchMulchCheckbox = document.getElementById('catch-mulch');
    const clientToggle = document.getElementById('client-toggle');
    const clientForm = document.getElementById('client-form');

    let map = null;
    let parcelLayer = null;
    let clippedBuildingsLayer = null;
    let clippedBuildingsGeoJSON = null;
    let negativeLayer = null;
    let areaOverlay = null;
    let parcelAreaM2 = 0;
    let currentLawnArea = 0;
    let currentData = null;
    let buildingsTransferredToExclusions = false;

    const LINZ_AERIAL_URL = 'https://basemaps.linz.govt.nz/v1/tiles/aerial/WebMercatorQuad/{z}/{x}/{y}.webp?api=c01ke53n73k729x0esp5je1k67a';

    // Client form toggle
    clientToggle.addEventListener('click', () => {
      clientForm.classList.toggle('open');
      clientToggle.querySelector('span').textContent = clientForm.classList.contains('open') ? '▲' : '▼';
    });

    // Difficulty slider display
    difficultySlider.addEventListener('input', () => {
      difficultyValue.textContent = difficultySlider.value + 'x';
      updateLawnArea();
    });

    catchMulchCheckbox.addEventListener('change', updateLawnArea);

    async function loadQuoteSettings(token) {
      try {
        const res = await fetch(`${WORKER_URL}/api/user/profile`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (res.ok) {
          const { profile } = await res.json();
          if (profile.quoteSettings) {
            const s = profile.quoteSettings;
            rateInput.value = s.ratePerM2 || 0.20;
            calloutInput.value = s.calloutFee || 80;
            estimatedHoursInput.value = s.estimatedHours || 1.0;
            hourlyRateInput.value = s.hourlyCost || 50;
            difficultySlider.value = s.difficultyMultiplier || 1.0;
            difficultyValue.textContent = difficultySlider.value + 'x';
            catchMulchCheckbox.checked = s.catchAndMulch || false;
            updateLawnArea();
          }
        }
      } catch (e) {
        console.warn('Could not load quote settings', e);
      }
    }

    async function saveQuoteSettings(token) {
      try {
        const res = await fetch(`${WORKER_URL}/api/user/profile`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (!res.ok) return;
        const { profile } = await res.json();

        profile.quoteSettings = {
          ratePerM2: parseFloat(rateInput.value) || 0.20,
          calloutFee: parseFloat(calloutInput.value) || 80,
          estimatedHours: parseFloat(estimatedHoursInput.value) || 1.0,
          hourlyCost: parseFloat(hourlyRateInput.value) || 50,
          difficultyMultiplier: parseFloat(difficultySlider.value) || 1.0,
          catchAndMulch: catchMulchCheckbox.checked
        };
        profile.updatedAt = new Date().toISOString();

        await fetch(`${WORKER_URL}/api/user/profile`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(profile)
        });
      } catch (e) {
        console.warn('Could not save quote settings', e);
      }
    }

    let saveTimeout;
    function scheduleSave(token) {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => saveQuoteSettings(token), 1000);
    }

    [rateInput, calloutInput, estimatedHoursInput, hourlyRateInput].forEach(input => {
      input.addEventListener('input', () => {
        updateLawnArea();
        if (auth.currentUser) {
          auth.currentUser.getIdToken().then(scheduleSave);
        }
      });
    });
    difficultySlider.addEventListener('input', () => {
      difficultyValue.textContent = difficultySlider.value + 'x';
      updateLawnArea();
      if (auth.currentUser) {
        auth.currentUser.getIdToken().then(scheduleSave);
      }
    });
    catchMulchCheckbox.addEventListener('change', () => {
      updateLawnArea();
      if (auth.currentUser) {
        auth.currentUser.getIdToken().then(scheduleSave);
      }
    });

    onAuthStateChanged(auth, async (user) => {
      if (user) {
        const token = await user.getIdToken();
        await loadQuoteSettings(token);
      }
    });

    function updateLawnArea() {
      console.log("=== Negative Layer Debug ===");
      const negativePolys = [];
      let individualAreas = [];
      let polygonCount = 0;

      if (negativeLayer) {
        negativeLayer.eachLayer(layer => {
          if (layer.getLatLngs && layer.getLatLngs().length > 0) {
            const latlngs = layer.getLatLngs()[0];
            if (Array.isArray(latlngs) && latlngs.length >= 3) {
              polygonCount++;
              const area = L.GeometryUtil.geodesicArea(latlngs);
              individualAreas.push(Math.round(area));
              const coords = latlngs.map(ll => [ll.lng, ll.lat]);
              coords.push(coords[0]);
              negativePolys.push(turf.polygon([coords]));
              console.log(`Polygon ${polygonCount} area: ${Math.round(area)} m²`);
            }
          }
        });
      }

      console.log(`Total polygons: ${polygonCount}`);
      console.log(`Individual areas: ${individualAreas.join(', ')} m²`);

      let negativeArea = 0;
      if (negativePolys.length > 0) {
        try {
          let unioned = negativePolys.reduce((acc, poly) => turf.union(acc, poly));
          negativeArea = turf.area(unioned);
          console.log(`Unioned negative area (no overlap): ${Math.round(negativeArea)} m²`);
        } catch (e) {
          console.warn('Union failed, using sum', e);
          individualAreas.forEach(a => negativeArea += a);
          console.log(`Fallback sum negative area: ${Math.round(negativeArea)} m²`);
        }
      }

      currentLawnArea = Math.max(0, parcelAreaM2 - Math.round(negativeArea));
      console.log(`Parcel area: ${parcelAreaM2} m²`);
      console.log(`Final lawn area: ${currentLawnArea} m²`);
      console.log("=== End Debug ===\n");

      if (areaOverlay && areaOverlay._div) {
        areaOverlay._div.innerHTML = `<strong>Lawn Area:</strong> ${currentLawnArea.toLocaleString()} m²`;
      }
      areaDisplay.textContent = `${currentLawnArea.toLocaleString()} m² (edited)`;
      finalAreaDisplay.textContent = `${currentLawnArea.toLocaleString()} m²`;

      const rate = parseFloat(rateInput.value) || 0;
      const callout = parseFloat(calloutInput.value) || 0;
      const difficulty = parseFloat(difficultySlider.value) || 1.0;
      const catchMulchFee = catchMulchCheckbox.checked ? 40 : 0;
      const hours = parseFloat(estimatedHoursInput.value) || 1;
      const hourlyCost = parseFloat(hourlyRateInput.value) || 0;

      const baseMowing = currentLawnArea * rate;
      const adjustedRevenue = (baseMowing * difficulty) + callout + catchMulchFee;
      const gst = adjustedRevenue * 0.15;
      const totalIncl = adjustedRevenue + gst;
      const estCost = hours * hourlyCost;
      const estProfit = adjustedRevenue - estCost;
      const profitPerHour = hours > 0 ? estProfit / hours : 0;

      document.getElementById('mowing-revenue').textContent = '$' + baseMowing.toFixed(2);
      document.getElementById('total-revenue').textContent = '$' + adjustedRevenue.toFixed(2);
      document.getElementById('gst').textContent = '$' + gst.toFixed(2);
      document.getElementById('total-incl').textContent = '$' + totalIncl.toFixed(2);
      document.getElementById('est-cost').textContent = '$' + estCost.toFixed(2);
      document.getElementById('est-profit').textContent = '$' + estProfit.toFixed(2);
      document.getElementById('profit-hour').textContent = '$' + profitPerHour.toFixed(2);
    }

    function ensureNegativeLayer() {
      if (!map) return null;
      if (!negativeLayer || !map.hasLayer(negativeLayer)) {
        if (negativeLayer) map.removeLayer(negativeLayer);
        negativeLayer = new L.FeatureGroup();
        map.addLayer(negativeLayer);
      }
      return negativeLayer;
    }

    function transferBuildingsToExclusions() {
      if (!clippedBuildingsLayer || buildingsTransferredToExclusions) return;

      ensureNegativeLayer();

      clippedBuildingsLayer.eachLayer(function(layer) {
        const latlngs = layer.getLatLngs();
        if (!latlngs || !latlngs.length) return;

        const newPolygon = L.polygon(latlngs, {
          color: "#ff4444",
          weight: 2,
          fillColor: "#ff4444",
          fillOpacity: 0.6
        });

        negativeLayer.addLayer(newPolygon);
      });

      map.removeLayer(clippedBuildingsLayer);
      clippedBuildingsLayer = null;
      buildingsTransferredToExclusions = true;

      updateLawnArea();
    }

    function enterEditMode(autoStartNewPolygon = false) {
      if (!map) return;

      ensureNegativeLayer();
      transferBuildingsToExclusions();

      if (!areaOverlay) {
        areaOverlay = L.control({ position: 'bottomleft' });
        areaOverlay.onAdd = function () {
          const div = L.DomUtil.create('div', 'leaflet-control leaflet-bar');
          div.style.cssText = `
            background: rgba(255,255,255,0.95);
            padding: 12px 18px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 3px 12px rgba(0,0,0,0.3);
          `;
          areaOverlay._div = div;
          div.innerHTML = 'Calculating...';
          return div;
        };
        areaOverlay.addTo(map);
      }

      updateLawnArea();

      // Grey out the opposite button
      if (autoStartNewPolygon) {
        document.getElementById('btn-edit-shapes').disabled = true;
        document.getElementById('btn-edit-shapes').style.opacity = '0.5';
        document.getElementById('btn-edit-shapes').style.cursor = 'not-allowed';
      } else {
        document.getElementById('btn-new-shape').disabled = true;
        document.getElementById('btn-new-shape').style.opacity = '0.5';
        document.getElementById('btn-new-shape').style.cursor = 'not-allowed';
      }

      // Show Finish button when entering edit/draw mode
      document.getElementById('btn-finish-editing').style.display = 'inline-block';

      if (autoStartNewPolygon) {
        const newPolygonDrawer = new L.Draw.Polygon(map, {
          allowDrawingOnDrag: false,
          touchExtend: false,
          shapeOptions: {
            color: '#ff4444',
            weight: 2,
            fillColor: '#ff4444',
            fillOpacity: 0.6
          }
        });
        newPolygonDrawer.enable();

        map.once('draw:created', (e) => {
          const layer = e.layer;
          negativeLayer.addLayer(layer);
          layer.editing.enable();
          updateLawnArea();
        });
      } else {
        negativeLayer.eachLayer(layer => {
          if (layer.editing) layer.editing.enable();
        });
      }
    }

    function finishEditing() {
      if (!map) return;

      if (map._drawHandler) {
        map._drawHandler.disable();
        map._drawHandler = null;
      }

      negativeLayer.eachLayer(layer => {
        if (layer.editing) layer.editing.disable();
      });

      if (areaOverlay) {
        areaOverlay.remove();
        areaOverlay = null;
      }

      // Hide Finish button and restore other buttons
      document.getElementById('btn-finish-editing').style.display = 'none';

      const btnNew = document.getElementById('btn-new-shape');
      const btnEdit = document.getElementById('btn-edit-shapes');
      btnNew.disabled = false;
      btnEdit.disabled = false;
      btnNew.style.opacity = '1';
      btnEdit.style.opacity = '1';
      btnNew.style.cursor = 'pointer';
      btnEdit.style.cursor = 'pointer';

      updateLawnArea();
    }

    function showAerialMap(data) {
      currentData = data;
      if (!data.aerial) {
        aerialContainer.style.display = 'none';
        return;
      }
      aerialContainer.classList.remove('hidden');
      if (map) map.remove();
      map = L.map('aerial-map').setView(data.aerial.center, data.aerial.zoom);

      L.tileLayer(LINZ_AERIAL_URL, {
        attribution: '© <a href="https://www.linz.govt.nz/data/licensing-and-using-data/attributing-linz-data">LINZ</a> Aerial Imagery',
        maxZoom: 24,
        tileSize: 256,
        zoomOffset: 0,
        noWrap: true
      }).addTo(map);

      parcelAreaM2 = data.parcel_area_m2 || 0;
      if (data.parcel_geometry) {
        parcelLayer = L.geoJSON(data.parcel_geometry, {
          style: { color: "#0066ff", weight: 2, fillOpacity: 0 }
        }).addTo(map);
      }

      if (data.parcel_geometry && data.buildings_geometries && data.buildings_geometries.length > 0) {
        try {
          let parcelPoly;
          if (data.parcel_geometry.type === "MultiPolygon") {
            parcelPoly = turf.multiPolygon(data.parcel_geometry.coordinates);
          } else {
            parcelPoly = turf.polygon(data.parcel_geometry.coordinates);
          }
          const clippedBuildings = [];
          data.buildings_geometries.forEach(geom => {
            try {
              if (geom.type === "Polygon" && geom.coordinates && geom.coordinates.length > 0) {
                const ring = geom.coordinates[0];
                if (ring.length >= 4) {
                  const cleaned = [];
                  ring.forEach((p, i) => {
                    const prev = ring[i === 0 ? ring.length - 1 : i - 1];
                    if (i === 0 || p[0] !== prev[0] || p[1] !== prev[1]) {
                      cleaned.push(p);
                    }
                  });
                  if (cleaned.length >= 4) {
                    if (cleaned[0][0] !== cleaned[cleaned.length - 1][0] || cleaned[0][1] !== cleaned[cleaned.length - 1][1]) {
                      cleaned.push(cleaned[0]);
                    }
                    const buildingPoly = turf.polygon([cleaned]);
                    const intersection = turf.intersect(parcelPoly, buildingPoly);
                    if (intersection && intersection.geometry) {
                      clippedBuildings.push(intersection.geometry);
                    }
                  }
                }
              }
            } catch (e) {}
          });
          if (clippedBuildings.length > 0) {
            clippedBuildingsGeoJSON = { type: "FeatureCollection", features: clippedBuildings.map(g => ({ type: "Feature", geometry: g })) };
            clippedBuildingsLayer = L.geoJSON(clippedBuildings, {
              style: { color: "#ff4444", weight: 2, fillColor: "#ff4444", fillOpacity: 0.5 }
            }).addTo(map);
          }
        } catch (e) {
          console.warn('Building clipping failed', e);
        }
      }

      if (parcelLayer) {
        map.fitBounds(parcelLayer.getBounds().pad(0.2));
      }

      buildingsTransferredToExclusions = false;
      ensureNegativeLayer();
      updateLawnArea();

      // Make sure Finish is hidden when map first loads
      document.getElementById('btn-finish-editing').style.display = 'none';

      pricingBox.classList.remove('hidden');
    }

    const btnNewShape = document.getElementById('btn-new-shape');
    const btnEditShapes = document.getElementById('btn-edit-shapes');
    const btnFinish = document.getElementById('btn-finish-editing');

    btnNewShape.addEventListener('click', () => {
      if (!map) {
        alert('Map not ready yet. Please load a property first.');
        return;
      }
      enterEditMode(true);
    });

    btnEditShapes.addEventListener('click', () => {
      if (!map) {
        alert('Map not ready yet. Please load a property first.');
        return;
      }
      enterEditMode(false);
    });

    btnFinish.addEventListener('click', () => {
      if (!map) {
        alert('Nothing to finish — map not loaded.');
        return;
      }
      finishEditing();
    });

    btn.addEventListener('click', async () => {
      const address = addressInput.value.trim();
      if (!address) {
        showError("Please enter a valid address");
        return;
      }
      hideError();
      resultDiv.classList.add('hidden');
      aerialContainer.classList.add('hidden');
      pricingBox.classList.add('hidden');
      btn.disabled = true;
      btn.textContent = "Looking up...";
      btn.classList.add('loading');
      try {
        const startTime = performance.now();
        let token = null;
        if (auth.currentUser) {
          token = await auth.currentUser.getIdToken(true);
        }
        const response = await fetch(`${WORKER_URL}/api/building-area?address=${encodeURIComponent(address)}`, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            ...(token ? { 'Authorization': `Bearer ${token}` } : {})
          }
        });
        const text = await response.text();
        let data;
        try {
          data = JSON.parse(text);
        } catch {
          throw new Error("Invalid response from server");
        }
        const timeTaken = ((performance.now() - startTime) / 1000).toFixed(1);
        if (!response.ok || data.error) {
          throw new Error(data.error || "Service error");
        }
        addressDisplay.textContent = data.address;
        areaDisplay.textContent = `${data.estimated_lawn_area_m2?.toLocaleString() || 'Calculating...'} m²`;
        timeDisplay.textContent = `Found in ${timeTaken} seconds`;
        resultDiv.classList.remove('hidden');
        showAerialMap(data);
      } catch (err) {
        showError(err.message || "Failed to fetch data");
      } finally {
        btn.disabled = false;
        btn.textContent = "Calculate Lawn Area";
        btn.classList.remove('loading');
      }
    });

    addressInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') btn.click();
    });

    function showError(msg) {
      errorDiv.textContent = msg;
      errorDiv.classList.remove('hidden');
    }

    function hideError() {
      errorDiv.classList.add('hidden');
      errorDiv.textContent = '';
    }

    document.getElementById('generate-pdf-btn').addEventListener('click', async () => {
      if (!currentData || currentLawnArea === 0) {
        alert('Please load an address and measure the lawn area first.');
        return;
      }
      if (!auth.currentUser) {
        alert('Please sign in to save quotes');
        window.location.href = 'login.html';
        return;
      }

      const token = await auth.currentUser.getIdToken();

      let companyProfile = {};
      try {
        const profileRes = await fetch(`${WORKER_URL}/api/user/profile`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (profileRes.ok) {
          const { profile } = await profileRes.json();
          companyProfile = {
            companyName: profile.companyName || 'Deep Edge',
            nzbn: profile.nzbn || '',
            phone: profile.phone || '',
            gstNumber: profile.gstNumber || '',
            email: profile.email || '',
            logoUrl: profile.logoUrl || ''
          };
        }
      } catch (e) {
        console.warn('Could not fetch company profile for quote', e);
      }

      const negativeGeoJSON = negativeLayer ? negativeLayer.toGeoJSON() : { type: "FeatureCollection", features: [] };

      const quoteData = {
        address: addressDisplay.textContent,
        lawnAreaM2: currentLawnArea,
        ratePerM2: parseFloat(rateInput.value) || 0,
        calloutFee: parseFloat(document.getElementById('callout-input').value) || 0,
        difficultyMultiplier: parseFloat(difficultySlider.value),
        catchAndMulch: catchMulchCheckbox.checked,
        estimatedHours: parseFloat(document.getElementById('estimated-hours').value) || 1,
        hourlyCost: parseFloat(document.getElementById('hourly-rate').value) || 0,
        client: {
          firstName: document.getElementById('client-first').value.trim(),
          lastName: document.getElementById('client-last').value.trim(),
          email: document.getElementById('client-email').value.trim(),
          phone: document.getElementById('client-phone').value.trim()
        },
        company: companyProfile,
        mapState: {
          center: map.getCenter(),
          zoom: map.getZoom(),
          parcelGeometry: currentData.parcel_geometry,
          buildingsGeoJSON: clippedBuildingsGeoJSON,
          negativeGeoJSON: negativeGeoJSON
        },
        generatedAt: new Date().toISOString()
      };

      try {
        const res = await fetch(`${WORKER_URL}/api/quotes`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(quoteData)
        });

        if (!res.ok) {
          const errText = await res.text();
          throw new Error(errText || 'Failed to save quote');
        }

        const { quoteId } = await res.json();
        const publicLink = `${window.location.origin}/roof/quote.html?quote=${quoteId}`;

        document.getElementById('quote-link').href = publicLink;
        document.getElementById('quote-link').textContent = publicLink;
        document.getElementById('quote-link-box').classList.remove('hidden');

        alert('Quote saved successfully!\n\nShare this link with your client:\n' + publicLink);
      } catch (err) {
        console.error('Quote save failed:', err);
        alert('Failed to save quote: ' + err.message);
      }
    });

    const suggestionsBox = document.getElementById("address-suggestions");
    let debounceTimer = null;

    addressInput.addEventListener("input", (e) => {
      const value = e.target.value.trim();

      clearTimeout(debounceTimer);

      if (value.length < 3) {
        hideSuggestions();
        return;
      }

      debounceTimer = setTimeout(() => {
        fetchSuggestions(value);
      }, 250);
    });

    async function fetchSuggestions(query) {
      try {
        const res = await fetch(
          `${WORKER_URL}/api/address-suggest?q=${encodeURIComponent(query)}`
        );

        if (!res.ok) return;

        const data = await res.json();
        renderSuggestions(data.addresses || []);
      } catch (err) {
        console.warn("Suggest failed", err);
      }
    }

    function renderSuggestions(addresses) {
      suggestionsBox.innerHTML = "";

      if (!addresses.length) {
        hideSuggestions();
        return;
      }

      addresses.forEach(addr => {
        const div = document.createElement("div");
        div.className = "suggestion-item";
        div.textContent = addr.FullAddress;

        div.addEventListener("click", () => {
          addressInput.value = addr.FullAddress;
          hideSuggestions();
        });

        suggestionsBox.appendChild(div);
      });

      suggestionsBox.classList.remove("hidden");
    }

    function hideSuggestions() {
      suggestionsBox.classList.add("hidden");
      suggestionsBox.innerHTML = "";
    }

    document.addEventListener("click", (e) => {
      if (!e.target.closest(".input-group")) {
        hideSuggestions();
      }
    });

  </script>
</body>
</html>