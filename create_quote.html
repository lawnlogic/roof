<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet">

  <title>Create Quote ‚Ä¢ Deep Edge</title>
  <link rel="stylesheet" href="styles.css">
  <script src="sms.js" defer></script>
  <link rel="stylesheet" href="./index-FsI4UGjo.css">
  <script src="header.js" defer></script>

  <!-- Leaflet + Draw -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <!-- Turf.js -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <style>
    /* Core custom styles - matching index.html and quote.html */
    :root {
      --background: 270 30% 97%;
      --foreground: 245 35% 15%;
      --card: 0 0% 100%;
      --primary: 288 52% 36%;
      --secondary: 270 20% 96%;
      --accent: 288 52% 36%;
      --border: 245 20% 88%;
      --radius: 1.75rem;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(135deg, #F3EEF9 0%, #F7F2FC 100%);
      color: hsl(var(--foreground));
      overflow-x: hidden;
      min-height: 100vh;
      padding: 5rem 20px 40px 20px;
      line-height: 1.45;
    }

    h1, h2, h3, h4, h5, h6 {
      font-family: 'Space Grotesk', sans-serif;
      letter-spacing: -0.02em;
      line-height: 0.98;
    }

    h1 { 
      font-size: 2.25rem; 
      font-weight: 800; 
      color: #1B1B2F; 
      letter-spacing: -0.5px; 
      margin-bottom: 8px; 
    }
    h2 { 
      font-size: 1.5rem; 
      font-weight: 700; 
      margin: 48px 0 28px; 
      color: #1B1B2F;
      letter-spacing: -0.3px;
    }
    h3 { 
      font-size: 1.25rem; 
      font-weight: 700; 
      margin-bottom: 24px; 
      color: #1B1B2F;
      letter-spacing: -0.2px;
    }

    .create-quote-container {
      width: 100%;
      max-width: 900px;
      margin: 0 auto;
    }

    .input-group {
      margin-bottom: 24px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .input-group label {
      color: #1B1B2F;
      font-weight: 600;
      font-size: 0.95rem;
      letter-spacing: -0.2px;
    }

    input[type="text"],
    input[type="number"],
    input[type="email"],
    select {
      padding: 14px 16px;
      border: 1px solid rgba(229, 231, 235, 0.5);
      border-radius: 14px;
      font-family: 'Inter', sans-serif;
      font-size: 0.95rem;
      background: rgba(255, 255, 255, 0.8);
      color: #1B1B2F;
      transition: all 0.25s ease;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    input[type="email"]:focus,
    select:focus {
      outline: none;
      border-color: #7B2D8E;
      background: white;
      box-shadow: 0 0 0 5px rgba(123, 45, 142, 0.08);
    }

    input[type="text"]::placeholder,
    input[type="number"]::placeholder,
    input[type="email"]::placeholder {
      color: #b4b7c3;
    }

    input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: linear-gradient(to right, #e5e7eb 0%, #f3f4f6 100%);
      outline: none;
      -webkit-appearance: none;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #7B2D8E;
      cursor: pointer;
      box-shadow: 0 3px 12px rgba(123, 45, 142, 0.25);
      transition: all 0.2s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 5px 16px rgba(123, 45, 142, 0.35);
    }

    input[type="range"]::-moz-range-thumb {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #7B2D8E;
      cursor: pointer;
      border: none;
      box-shadow: 0 3px 12px rgba(123, 45, 142, 0.25);
      transition: all 0.2s ease;
    }

    input[type="range"]::-moz-range-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 5px 16px rgba(123, 45, 142, 0.35);
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 18px 20px;
      background: rgba(247, 242, 252, 0.6);
      border: 1px solid rgba(229, 231, 235, 0.4);
      border-radius: 14px;
      margin-bottom: 24px;
      transition: all 0.25s ease;
    }

    .checkbox-group:hover {
      background: rgba(247, 242, 252, 0.9);
      border-color: rgba(123, 45, 142, 0.2);
    }

    .checkbox-group label {
      margin: 0;
      cursor: pointer;
      color: #1B1B2F;
      font-weight: 500;
      flex: 1;
    }

    .checkbox-group input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
      accent-color: #7B2D8E;
    }

    input[readonly] {
      background: rgba(249, 250, 251, 0.7);
      color: #6b7280;
    }

    .slider-container {
      margin-bottom: 32px;
      background: rgba(247, 242, 252, 0.4);
      padding: 20px;
      border-radius: 14px;
      border: 1px solid rgba(229, 231, 235, 0.3);
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      color: #1B1B2F;
      font-weight: 600;
    }

    .suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid rgba(229, 231, 235, 0.6);
      border-radius: 14px;
      box-shadow: 0 10px 32px rgba(27, 27, 47, 0.12);
      max-height: 300px;
      overflow-y: auto;
      z-index: 100;
      margin-top: 8px;
    }

    .suggestion-item {
      padding: 14px 16px;
      cursor: pointer;
      color: #1B1B2F;
      transition: all 0.2s ease;
      border-bottom: 1px solid rgba(229, 231, 235, 0.3);
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .suggestion-item:hover {
      background: rgba(247, 242, 252, 0.6);
      color: #7B2D8E;
      padding-left: 20px;
    }

    .action-button {
      background: #7B2D8E;
      color: white;
      padding: 13px 28px;
      border: none;
      border-radius: 9999px;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 6px 20px rgba(123, 45, 142, 0.2);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .action-button:hover {
      background: #662375;
      transform: translateY(-3px);
      box-shadow: 0 10px 28px rgba(123, 45, 142, 0.3);
    }

    .action-button:active {
      transform: translateY(-1px);
      box-shadow: 0 4px 15px rgba(123, 45, 142, 0.2);
    }

    .action-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .action-button.secondary {
      background: rgba(229, 231, 235, 0.8);
      color: #1B1B2F;
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.08);
    }

    .action-button.secondary:hover {
      background: #e5e7eb;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
    }

    .result,
    .error {
      background: white;
      border: 1px solid rgba(229, 231, 235, 0.6);
      border-radius: 18px;
      padding: 28px;
      margin: 28px 0;
      box-shadow: 0 8px 28px rgba(27, 27, 47, 0.08);
      transition: all 0.3s ease;
    }

    .result:hover {
      box-shadow: 0 12px 36px rgba(27, 27, 47, 0.12);
    }

    .error {
      border-color: rgba(254, 202, 202, 0.6);
      background: rgba(254, 242, 242, 0.8);
      color: #dc2626;
    }

    #address-display {
      font-size: 1.15rem;
      font-weight: 700;
      color: #1B1B2F;
      margin-bottom: 16px;
      letter-spacing: -0.2px;
    }

    #area, #time {
      color: #6b7280;
      margin: 10px 0;
      font-size: 0.95rem;
      line-height: 1.5;
    }

    #area strong, #time strong {
      color: #7B2D8E;
      font-weight: 700;
    }

    .hidden {
      display: none !important;
    }

    #aerial-container {
      margin: 48px 0;
      background: white;
      border: 1px solid rgba(229, 231, 235, 0.6);
      border-radius: 20px;
      padding: 28px;
      box-shadow: 0 24px 70px rgba(27, 27, 47, 0.08);
      transition: all 0.3s ease;
    }

    #aerial-container:hover {
      box-shadow: 0 32px 80px rgba(27, 27, 47, 0.12);
    }

    #aerial-container h2 {
      margin: 0 0 12px 0;
    }

    #aerial-container p {
      color: #6b7280;
      margin-bottom: 24px;
      line-height: 1.6;
    }

    #aerial-map {
      width: 100%;
      height: 500px;
      border-radius: 16px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      margin-bottom: 20px;
    }

    @media (min-width: 768px) {
      #aerial-map {
        height: 600px;
      }
    }

    .map-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      padding: 24px;
      justify-content: center;
      background: rgba(247, 242, 252, 0.4);
      border-radius: 14px;
      margin-top: 20px;
    }

    .map-controls .action-button {
      min-width: 120px;
    }

    .pricing-box {
      background: white;
      border: 1px solid rgba(229, 231, 235, 0.6);
      border-radius: 20px;
      padding: 32px;
      box-shadow: 0 24px 70px rgba(27, 27, 47, 0.08);
      margin: 28px 0;
      transition: all 0.3s ease;
    }

    .pricing-box:hover {
      transform: translateY(-4px);
      box-shadow: 0 32px 90px rgba(123, 45, 142, 0.12);
    }

    .pricing-box h3 {
      margin-bottom: 28px;
    }

    .pricing-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 0;
      border-bottom: 1px solid rgba(229, 231, 235, 0.5);
      font-size: 0.95rem;
    }

    .pricing-row span {
      color: #6b7280;
      font-weight: 500;
    }

    .pricing-row strong {
      color: #1B1B2F;
      font-weight: 600;
    }

    .pricing-row:last-of-type {
      border-bottom: 2px solid rgba(229, 231, 235, 0.6);
      padding: 22px 0;
      margin-top: 8px;
    }

    .pricing-row:last-of-type strong {
      color: #7B2D8E;
      font-size: 1.25rem;
      font-weight: 700;
    }

    #generate-pdf-btn {
      width: 100%;
      margin-top: 32px;
    }

    #quote-link-box {
      margin-top: 24px;
      padding: 20px;
      background: rgba(240, 249, 255, 0.6);
      border: 1px solid rgba(191, 219, 254, 0.5);
      border-radius: 14px;
      color: #1e40af;
      font-size: 0.9rem;
      line-height: 1.6;
    }

    #quote-link-box a {
      color: #7B2D8E;
      word-break: break-all;
      text-decoration: none;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    #quote-link-box a:hover {
      color: #662375;
      text-decoration: underline;
    }

    #address-suggestions {
      position: relative;
      z-index: 100;
    }

    #result, #error {
      position: relative;
    }

    #loading-splash {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, #F3EEF9 0%, #F7F2FC 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 1;
      visibility: visible;
      transition: opacity 0.5s ease, visibility 0.5s ease;
    }

    #loading-splash.fade-out {
      opacity: 0;
      visibility: hidden;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid #e5e7eb;
      border-top-color: #7B2D8E;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #loading-splash p {
      font-size: 1.1rem;
      color: #6E6E82;
      font-weight: 500;
    }

    .mower-type-group {
      display: flex;
      gap: 20px;
      margin: 20px 0 24px;
      flex-wrap: wrap;
    }

    .mower-type-group label {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      padding: 13px 18px;
      background: rgba(255, 255, 255, 0.7);
      border: 2px solid rgba(229, 231, 235, 0.6);
      border-radius: 12px;
      font-weight: 500;
      color: #1B1B2F;
      transition: all 0.25s ease;
    }

    .mower-type-group label:hover {
      border-color: #7B2D8E;
      background: rgba(247, 242, 252, 0.9);
    }

    .mower-type-group input[type="radio"] {
      margin: 0;
      cursor: pointer;
      accent-color: #7B2D8E;
    }

    .mower-type-group input[type="radio"]:checked + label,
    .mower-type-group label input[type="radio"]:checked {
      border-color: #7B2D8E;
      background: rgba(247, 242, 252, 0.95);
      box-shadow: 0 0 0 3px rgba(123, 45, 142, 0.08);
    }

    @media (max-width: 768px) {
      body {
        padding: 4.5rem 16px 24px 16px;
      }

      h1 { 
        font-size: 1.75rem; 
      }
      h2 { 
        font-size: 1.25rem; 
        margin: 28px 0 20px; 
      }

      .create-quote-container {
        max-width: 100%;
      }

      .pricing-box {
        padding: 24px;
      }

      .result, .error {
        padding: 20px;
        margin: 20px 0;
      }

      #aerial-map {
        height: 400px;
      }

      .map-controls {
        padding: 16px;
        gap: 10px;
      }

      .map-controls .action-button {
        min-width: auto;
        padding: 11px 14px;
        font-size: 0.85rem;
      }

      .action-button {
        padding: 12px 24px;
        font-size: 0.9rem;
      }

      .input-group {
        margin-bottom: 20px;
      }

      .slider-container {
        padding: 16px;
        margin-bottom: 24px;
      }

      .checkbox-group {
        padding: 16px;
        margin-bottom: 20px;
      }
    }
  </style>
</head>

<body>
  <!-- Loading Splash Screen -->
  <div id="loading-splash">
    <div class="spinner"></div>
    <p>Loading property data...</p>
  </div>

  <div class="create-quote-container">
    <h1>Create Quote</h1>
    <p style="margin: 16px 0 36px 0; color: #6b7280; font-size: 1.05rem; line-height: 1.6; max-width: 600px;">
      Enter a property address to create a beautiful, professional quote. We'll measure the lawn, show you the aerial view, and let you customize the pricing details.
    </p>

    <!-- Address Input Section -->
    <div class="input-group">
      <label for="address">Property Address</label>
      <div style="position: relative;">
        <input type="text" id="address" placeholder="E.g., 123 Main Street, Auckland..." autocomplete="off" />
        <div id="address-suggestions" class="suggestions hidden"></div>
      </div>
    </div>

    <button id="lookup-btn" class="action-button">üîç Calculate Lawn Area</button>

    <div id="result" class="result hidden">
      <div id="address-display"></div>
      <div id="area"></div>
      <div id="time"></div>
    </div>

    <div id="error" class="error hidden"></div>

    <!-- Aerial Map Section -->
    <div id="aerial-container" class="hidden">
      <h2>Aerial View & Lawn Measurement</h2>
      <p>Edit the map to exclude everything that won't be mowed (buildings, driveways, gardens, etc.)</p>

      <div id="aerial-map"></div>
      
      <!-- Control buttons -->
      <div class="map-controls">
        <button id="btn-new-shape" class="action-button">‚ûï New Area</button>
        <button id="btn-edit-shapes" class="action-button secondary">‚úèÔ∏è Edit Areas</button>
        <button id="btn-finish-editing" class="action-button" style="display: none;">‚úì Finish Editing</button>
      </div>
    </div>

    <!-- Quote Settings Card -->
    <div id="pricing-box" class="pricing-box hidden">
      <h3>Quote Details</h3>

      <div class="input-group">
        <label for="quote-number">Quote Number (optional)</label>
        <input type="text" id="quote-number" placeholder="e.g. Q-042 or 2026-015" />
      </div>

      <!-- Mower Type Selection -->
      <div class="input-group">
        <label>Mower Type</label>
        <div class="mower-type-group">
          <label style="display: flex; align-items: center; gap: 8px; margin: 0;">
            <input type="radio" name="mowerType" value="push" id="mower-push" checked />
            Push Mower
          </label>
          <label style="display: flex; align-items: center; gap: 8px; margin: 0;">
            <input type="radio" name="mowerType" value="rideon" id="mower-rideon" />
            Ride-on Mower
          </label>
        </div>
      </div>

      <div class="input-group">
        <label for="estimated-job-time">Estimated Job Time (hours)</label>
        <input type="number" id="estimated-job-time" value="0.0" step="0.25" min="0" readonly />
      </div>

      <div class="input-group">
        <label for="callout-input">Call-out / Travel Fee (ex GST)</label>
        <input type="number" id="callout-input" value="80" step="10" min="0" />
      </div>

      <!-- Difficulty Multiplier -->
      <div class="slider-container">
        <div class="slider-label">
          <span>Job Difficulty Multiplier</span>
          <span id="difficulty-value">1.0x</span>
        </div>
        <input type="range" id="difficulty-slider" min="1.0" max="2.0" step="0.1" value="1.0" />
      </div>

      <!-- Catch & Mulch -->
      <div class="checkbox-group">
        <label for="catch-mulch">Catch & Mulch Service</label>
        <span style="color: #7B2D8E; font-weight: 600;">+$40 ex GST</span>
        <input type="checkbox" id="catch-mulch" />
      </div>

      <!-- Pricing Summary -->
      <div style="margin-top: 40px; padding-top: 32px; border-top: 2px solid rgba(229, 231, 235, 0.4);">
        <h3 style="margin-bottom: 28px; font-size: 1.3rem;">Pricing Summary</h3>
        
        <div class="pricing-row">
          <span>Lawn Area</span>
          <strong id="final-area">0 m¬≤</strong>
        </div>
        <div class="pricing-row">
          <span>Callout Fee (ex GST)</span>
          <strong style="color: #1B1B2F;" id="callout-display">$0.00</strong>
        </div>
        <div class="pricing-row">
          <span>Catch & Mulch (ex GST)</span>
          <strong style="color: #1B1B2F;" id="catch-mulch-display">$0.00</strong>
        </div>
        <div class="pricing-row">
          <span>Subtotal (ex GST)</span>
          <strong id="total-revenue">$0.00</strong>
        </div>
        <div class="pricing-row">
          <span>GST (15%)</span>
          <strong id="gst">$0.00</strong>
        </div>
        <div class="pricing-row">
          <span>Total (incl GST)</span>
          <strong id="total-incl">$0.00</strong>
        </div>
      </div>

      <button id="generate-pdf-btn" class="action-button">üîó Generate Quote Link</button>
      <div id="quote-link-box" class="hidden">
        <strong style="font-size: 0.95rem;">Share this quote with your client:</strong><br>
        <a id="quote-link" href="#" target="_blank" style="display: block; margin: 12px 0;"></a>
        <button onclick="copyQuoteLink()" class="action-button secondary" style="margin-top: 16px; width: auto; font-size: 0.9rem;">üìã Copy Link</button>
      </div>
    </div>
  </div>

  <script type="module">
    // Copy quote link function
    window.copyQuoteLink = function() {
      const quoteLink = document.getElementById('quote-link').href;
      navigator.clipboard.writeText(quoteLink).then(() => {
        const btn = event.target;
        const originalText = btn.innerHTML;
        const originalClass = btn.className;
        btn.innerHTML = '‚úì Copied!';
        btn.classList.remove('secondary');
        btn.style.background = '#10b981';
        btn.style.color = 'white';
        setTimeout(() => {
          btn.innerHTML = originalText;
          btn.className = originalClass;
          btn.style.background = '';
          btn.style.color = '';
        }, 2000);
      }).catch(() => {
        alert('Failed to copy link');
      });
    };

    // Prevent adding vertex on touchstart ‚Üí drag (common mobile bug)
    if (L.Draw && L.Draw.Polyline) {
        L.Draw.Polyline.include({
            _onTouch: function (e) {
                if (e.type === 'touchstart') {
                    this._touchStartTime = Date.now();
                    return;
                }
                
                if (e.type === 'touchend' || e.type === 'touchcancel') {
                    const duration = Date.now() - (this._touchStartTime || 0);
                    if (duration < 250) {  // short tap ‚Üí accept as click
                        L.Draw.Polyline.prototype._onTouchOriginal.call(this, e);
                    }
                    this._touchStartTime = null;
                }
            }
        });

        if (!L.Draw.Polyline.prototype._onTouchOriginal) {
            L.Draw.Polyline.prototype._onTouchOriginal = L.Draw.Polyline.prototype._onTouch;
            L.Draw.Polyline.prototype._onTouch = L.Draw.Polyline.prototype._onTouch;
        }
    }

    const firebaseConfig = {
      apiKey: "AIzaSyAzS6a2JbgFxSJLPi2-sWyflOfrE7jd73g",
      authDomain: "deep-edge-cc5bd.firebaseapp.com",
      projectId: "deep-edge-cc5bd",
      storageBucket: "deep-edge-cc5bd.firebasestorage.app",
      messagingSenderId: "23198790796",
      appId: "1:23198790796:web:616de764b8a8db2ae1f7a9",
      measurementId: "G-GLYGPCHRXM"
    };
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);

    const urlParams = new URLSearchParams(window.location.search);
    const jobId = urlParams.get('jobId');
    const WORKER_URL = "https://firebase-protected-backend.jamesisarad.workers.dev";

    // Show loading splash initially
    const loadingSplash = document.getElementById('loading-splash');
    let loadedJobData = null; // Store job data for client info in quotes
    
    if (jobId) {
      onAuthStateChanged(auth, async (user) => {
        if (user) {
          try {
            const token = await user.getIdToken();
            const res = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
              headers: { 'Authorization': `Bearer ${token}` }
            });

            if (res.ok) {
              const job = await res.json();
              loadedJobData = job; // Store full job data
              if (job.address) {
                document.getElementById('address').value = job.address;
                // Auto-trigger search and hide splash when complete
                setTimeout(() => {
                  document.getElementById('lookup-btn').click();
                }, 300);
              }
            }
          } catch (err) {
            console.warn("Failed to pre-fill job address:", err);
            if (loadingSplash) {
              loadingSplash.classList.add('fade-out');
              setTimeout(() => loadingSplash.style.display = 'none', 500);
            }
          }
        }
      });
    } else {
      // No jobId ‚Üí hide splash immediately
      if (loadingSplash) {
        loadingSplash.classList.add('fade-out');
        setTimeout(() => loadingSplash.style.display = 'none', 500);
      }
    }

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = 'login.html';
        return;
      }
    });

    //Detect edits
    const quoteId = urlParams.get('quote');
    const isEditMode = urlParams.get('edit') === 'true' && quoteId;
    let editingQuoteId = null;
    let editingQuoteData = null;

    if (isEditMode) {
      document.getElementById('generate-pdf-btn').textContent = "Update Quote";
    }

    const btn = document.getElementById('lookup-btn');
    const addressInput = document.getElementById('address');
    const resultDiv = document.getElementById('result');
    const errorDiv = document.getElementById('error');
    const addressDisplay = document.getElementById('address-display');
    const areaDisplay = document.getElementById('area');
    const timeDisplay = document.getElementById('time');
    const aerialContainer = document.getElementById('aerial-container');
    const pricingBox = document.getElementById('pricing-box');
    const calloutInput = document.getElementById('callout-input');
    const difficultySlider = document.getElementById('difficulty-slider');
    const difficultyValue = document.getElementById('difficulty-value');
    const catchMulchCheckbox = document.getElementById('catch-mulch');
    const estimatedJobTimeInput = document.getElementById('estimated-job-time');
    const finalAreaDisplay = document.getElementById('final-area');

    let map = null;
    let parcelLayer = null;
    let clippedBuildingsLayer = null;
    let clippedBuildingsGeoJSON = null;
    let negativeLayer = null;
    let areaOverlay = null;
    let parcelAreaM2 = 0;
    let currentLawnArea = 0;
    let currentData = null;
    let buildingsTransferredToExclusions = false;
    let profileMowingPricing = null;

    const LINZ_AERIAL_URL = 'https://basemaps.linz.govt.nz/v1/tiles/aerial/WebMercatorQuad/{z}/{x}/{y}.webp?api=c01ke53n73k729x0esp5je1k67a';

    // Mower type change listeners
    document.querySelectorAll('input[name="mowerType"]').forEach(radio => {
      radio.addEventListener('change', () => {
        updateEstimatedJobTime();
        updateLawnArea();
      });
    });

    async function loadQuoteSettingsAndPricing(token) {
      try {
        const res = await fetch(`${WORKER_URL}/api/user/profile`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (res.ok) {
          const { profile } = await res.json();
          if (profile.quoteSettings) {
            const s = profile.quoteSettings;
            calloutInput.value = s.calloutFee || 80;
            difficultySlider.value = s.difficultyMultiplier || 1.0;
            difficultyValue.textContent = difficultySlider.value + 'x';
            catchMulchCheckbox.checked = s.catchAndMulch || false;
          }
          if (profile.mowingPricing) {
            profileMowingPricing = profile.mowingPricing;
            if (!document.querySelector('input[name="mowerType"]:checked')) {
              document.getElementById('mower-push').checked = true;
            }
          }
          updateEstimatedJobTime();
          updateLawnArea();
        }
      } catch (e) {
        console.warn('Could not load profile settings', e);
      }
    }

    async function saveQuoteSettings(token) {
      try {
        const res = await fetch(`${WORKER_URL}/api/user/profile`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (!res.ok) return;
        const { profile } = await res.json();

        profile.quoteSettings = {
          calloutFee: parseFloat(calloutInput.value) || 80,
          difficultyMultiplier: parseFloat(difficultySlider.value) || 1.0,
          catchAndMulch: catchMulchCheckbox.checked
        };
        profile.updatedAt = new Date().toISOString();

        await fetch(`${WORKER_URL}/api/user/profile`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(profile)
        });
      } catch (e) {
        console.warn('Could not save quote settings', e);
      }
    }

    let saveTimeout;
    function scheduleSave(token) {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => saveQuoteSettings(token), 1000);
    }

    [calloutInput].forEach(input => {
      input.addEventListener('input', () => {
        updateLawnArea();
        if (auth.currentUser) {
          auth.currentUser.getIdToken().then(scheduleSave);
        }
      });
    });

    difficultySlider.addEventListener('input', () => {
      difficultyValue.textContent = difficultySlider.value + 'x';
      updateLawnArea();
      if (auth.currentUser) {
        auth.currentUser.getIdToken().then(scheduleSave);
      }
    });

    catchMulchCheckbox.addEventListener('change', () => {
      updateLawnArea();
      if (auth.currentUser) {
        auth.currentUser.getIdToken().then(scheduleSave);
      }
    });

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = 'login.html';
        return;
      }

      const token = await user.getIdToken();

      await loadQuoteSettingsAndPricing(token);

      // ‚îÄ‚îÄ Load quote if editing ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (isEditMode && quoteId) {
        try {
          const token = await user.getIdToken();  // keep it anyway, in case backend logs it or something

          // Use the PUBLIC endpoint that we know works
          const res = await fetch(`${WORKER_URL}/api/public/quote/${quoteId}`, {
            headers: { 'Authorization': `Bearer ${token}` }  // optional but harmless
          });

          if (!res.ok) {
            const errText = await res.text();
            throw new Error(errText || `Quote not found (status ${res.status})`);
          }

          const quote = await res.json();
          editingQuoteData = quote;
          editingQuoteId   = quoteId;

          // ‚îÄ‚îÄ The rest stays exactly the same ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          // Populate fields
          document.getElementById('quote-number').value = quote.quoteNumber || '';
          document.getElementById('callout-input').value = quote.calloutFee ?? 80;
          document.getElementById('difficulty-slider').value = quote.difficultyMultiplier ?? 1.0;
          document.getElementById('difficulty-value').textContent = `${quote.difficultyMultiplier ?? 1.0}x`;
          document.getElementById('catch-mulch').checked = !!quote.catchAndMulch;

          const mowerRadio = document.getElementById(`mower-${quote.mowerType || 'push'}`);
          if (mowerRadio) mowerRadio.checked = true;

          // UX hint
          document.querySelector('h2').textContent = `Editing Quote ${quote.quoteNumber || quoteId}`;

          // Auto-load map + exclusions
          if (quote.address) {
            document.getElementById('address').value = quote.address;
            setTimeout(() => document.getElementById('lookup-btn').click(), 300);
          }

        } catch (err) {
          console.error("Failed to load quote for editing", err);
          showError("Could not load quote for editing: " + err.message);
        }
      }
    });


    function getSelectedMowerType() {
      const selected = document.querySelector('input[name="mowerType"]:checked');
      return selected ? selected.value : 'push';
    }

    function roundUpToQuarterHour(hours) {
      if (hours <= 0) return 0;
      return Math.ceil(hours * 4) / 4;
    }

    function updateEstimatedJobTime() {
      if (!currentLawnArea || !profileMowingPricing) {
        estimatedJobTimeInput.value = "0.0";
        return;
      }

      const type = getSelectedMowerType();
      const settings = profileMowingPricing[type];

      if (!settings || !settings.m2PerHour || settings.m2PerHour <= 0) {
        estimatedJobTimeInput.value = "0.0";
        return;
      }

      const rawHours = currentLawnArea / settings.m2PerHour;
      const roundedHours = roundUpToQuarterHour(rawHours);
      estimatedJobTimeInput.value = roundedHours.toFixed(2);
    }

        function updateLawnArea() {
      console.log("=== Negative Layer Debug ===");
      const negativePolys = [];
      let individualAreas = [];
      let polygonCount = 0;

      if (negativeLayer) {
        negativeLayer.eachLayer(layer => {
          if (layer.getLatLngs && layer.getLatLngs().length > 0) {
            const latlngs = layer.getLatLngs()[0];
            if (Array.isArray(latlngs) && latlngs.length >= 3) {
              polygonCount++;
              const area = L.GeometryUtil.geodesicArea(latlngs);
              individualAreas.push(Math.round(area));
              const coords = latlngs.map(ll => [ll.lng, ll.lat]);
              coords.push(coords[0]);
              negativePolys.push(turf.polygon([coords]));
              console.log(`Polygon ${polygonCount} area: ${Math.round(area)} m¬≤`);
            }
          }
        });
      }

      console.log(`Total polygons: ${polygonCount}`);
      console.log(`Individual areas: ${individualAreas.join(', ')} m¬≤`);

      let negativeArea = 0;
      if (negativePolys.length > 0) {
        try {
          let unioned = negativePolys.reduce((acc, poly) => turf.union(acc, poly));
          negativeArea = turf.area(unioned);
          console.log(`Unioned negative area (no overlap): ${Math.round(negativeArea)} m¬≤`);
        } catch (e) {
          console.warn('Union failed, using sum', e);
          individualAreas.forEach(a => negativeArea += a);
          console.log(`Fallback sum negative area: ${Math.round(negativeArea)} m¬≤`);
        }
      }

      currentLawnArea = Math.max(0, parcelAreaM2 - Math.round(negativeArea));
      console.log(`Parcel area: ${parcelAreaM2} m¬≤`);
      console.log(`Final lawn area: ${currentLawnArea} m¬≤`);
      console.log("=== End Debug ===\n");

      if (areaOverlay && areaOverlay._div) {
        areaOverlay._div.innerHTML = `<strong>Lawn Area:</strong> ${currentLawnArea.toLocaleString()} m¬≤`;
      }
      areaDisplay.textContent = `${currentLawnArea.toLocaleString()} m¬≤ (edited)`;
      finalAreaDisplay.textContent = `${currentLawnArea.toLocaleString()} m¬≤`;

      updateEstimatedJobTime();

      // ‚îÄ‚îÄ NEW PRICING LOGIC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const type = getSelectedMowerType();
      const settings = profileMowingPricing?.[type] || {};
      const chargeOutRate  = settings.chargeOutRate  || 0;
      const hourlyExpenses = settings.hourlyExpenses || 0;

      const rawHours = currentLawnArea / (settings.m2PerHour || 1);   // avoid div by zero
      const billedHours = roundUpToQuarterHour(rawHours);

      const mowingRevenue   = billedHours * chargeOutRate;
      const callout         = parseFloat(calloutInput.value) || 0;
      const catchMulchFee   = catchMulchCheckbox.checked ? 40 : 0;
      const difficulty      = parseFloat(difficultySlider.value) || 1.0;

      const adjustedMowing  = mowingRevenue * difficulty;
      const totalRevenueEx  = adjustedMowing + callout + catchMulchFee;

      const gst             = totalRevenueEx * 0.15;
      const totalIncl       = totalRevenueEx + gst;

      const estCost         = billedHours * hourlyExpenses;
      const estProfit       = totalRevenueEx - estCost;
      const profitPerHour   = billedHours > 0 ? estProfit / billedHours : 0;

      // Update displays
      document.getElementById('callout-display').textContent = '$' + callout.toFixed(2);
      document.getElementById('catch-mulch-display').textContent = '$' + catchMulchFee.toFixed(2);
      document.getElementById('total-revenue').textContent  = '$' + totalRevenueEx.toFixed(2);
      document.getElementById('gst').textContent            = '$' + gst.toFixed(2);
      document.getElementById('total-incl').textContent     = '$' + totalIncl.toFixed(2);
      // Only update if elements exist
      const estCostEl = document.getElementById('est-cost');
      const estProfitEl = document.getElementById('est-profit');
      const profitHourEl = document.getElementById('profit-hour');
      if (estCostEl) estCostEl.textContent = '$' + estCost.toFixed(2);
      if (estProfitEl) estProfitEl.textContent = '$' + estProfit.toFixed(2);
      if (profitHourEl) profitHourEl.textContent = '$' + profitPerHour.toFixed(2);
    }

    function constrainPointToParcel(latlng) {
      if (!parcelLayer) return latlng;
      
      // Get parcel geometry
      const parcelGeometry = parcelLayer.toGeoJSON().features[0]?.geometry;
      if (!parcelGeometry) return latlng;
      
      // Check if point is inside parcel
      const point = turf.point([latlng.lng, latlng.lat]);
      const polygon = turf.polygon(parcelGeometry.coordinates);
      
      if (turf.booleanPointInPolygon(point, polygon)) {
        return latlng; // Point is inside, keep it
      }
      
      // Point is outside - find closest point on boundary
      const polygonLine = turf.polygonToLine(polygon);
      const nearestPoint = turf.nearestPointOnLine(point, polygonLine);
      
      return L.latLng(nearestPoint.geometry.coordinates[1], nearestPoint.geometry.coordinates[0]);
    }

    function clipPolygonToParcel(layer) {
      if (!parcelLayer) {
        console.log('[CLIP] No parcel layer');
        return;
      }
      
      const latLngs = layer.getLatLngs()[0] || layer.getLatLngs();
      console.log(`[CLIP] Starting with ${latLngs.length} points`);
      
      if (latLngs.length < 3) {
        console.log('[CLIP] Less than 3 points, skipping');
        return;
      }
      
      // Get parcel boundary points
      let parcelBoundaryLatLngs = [];
      try {
        const parcelGeoJSON = parcelLayer.toGeoJSON();
        const parcelGeometry = parcelGeoJSON.features?.[0]?.geometry || parcelGeoJSON.geometry;
        
        if (parcelGeometry && parcelGeometry.coordinates) {
          // For Polygon, coordinates[0] is the outer ring
          const coords = parcelGeometry.coordinates[0] || parcelGeometry.coordinates;
          parcelBoundaryLatLngs = coords.map(coord => L.latLng(coord[1], coord[0]));
          console.log(`[CLIP] Parcel has ${parcelBoundaryLatLngs.length} boundary points`);
        } else {
          console.log('[CLIP] Cannot extract parcel coordinates');
          return;
        }
      } catch (err) {
        console.error('[CLIP] Error extracting parcel coordinates:', err);
        return;
      }
      
      let modified = false;
      const clippedLatLngs = [];
      
      // For each point, check if it's inside the parcel
      for (let i = 0; i < latLngs.length; i++) {
        const point = latLngs[i];
        
        // Simple point-in-polygon using ray casting
        const isInside = isPointInPolygon(point, parcelBoundaryLatLngs);
        console.log(`[CLIP] Point ${i} [${point.lat.toFixed(6)}, ${point.lng.toFixed(6)}]: ${isInside ? 'INSIDE' : 'OUTSIDE'}`);
        
        if (isInside) {
          clippedLatLngs.push(point);
        } else {
          // Point is outside - snap to nearest boundary point
          console.log(`[CLIP] Point ${i} is OUTSIDE - snapping to boundary`);
          const snappedPoint = snapPointToBoundary(point, parcelBoundaryLatLngs);
          console.log(`[CLIP] Snapped to [${snappedPoint.lat.toFixed(6)}, ${snappedPoint.lng.toFixed(6)}]`);
          clippedLatLngs.push(snappedPoint);
          modified = true;
        }
      }
      
      if (modified) {
        console.log(`[CLIP] Updating layer with ${clippedLatLngs.length} clipped points`);
        try {
          layer.setLatLngs(clippedLatLngs);
          console.log('[CLIP] Layer updated successfully');
        } catch (err) {
          console.error('[CLIP] Error updating layer:', err);
        }
      }
    }
    
    function isPointInPolygon(point, polygon) {
      // Ray casting algorithm
      let inside = false;
      const x = point.lng, y = point.lat;
      
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].lng, yi = polygon[i].lat;
        const xj = polygon[j].lng, yj = polygon[j].lat;
        
        const intersect = ((yi > y) !== (yj > y))
          && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      
      return inside;
    }
    
    function snapPointToBoundary(point, boundaryLatLngs) {
      // Find the closest point on the boundary
      let closestPoint = boundaryLatLngs[0];
      let minDistance = point.distanceTo(closestPoint);
      
      for (let i = 1; i < boundaryLatLngs.length; i++) {
        const distance = point.distanceTo(boundaryLatLngs[i]);
        if (distance < minDistance) {
          minDistance = distance;
          closestPoint = boundaryLatLngs[i];
        }
      }
      
      return closestPoint;
    }

    function attachConstraintListeners(layer) {
      if (layer.editing) {
        layer.on('edit', (e) => {
          updateLawnArea();
        });
      }
    }

    function ensureNegativeLayer() {
      if (!map) return null;
      if (!negativeLayer || !map.hasLayer(negativeLayer)) {
        if (negativeLayer) map.removeLayer(negativeLayer);
        negativeLayer = new L.FeatureGroup();
        map.addLayer(negativeLayer);
      }
      return negativeLayer;
    }

    function transferBuildingsToExclusions() {
      if (!clippedBuildingsLayer || buildingsTransferredToExclusions) return;

      ensureNegativeLayer();

      clippedBuildingsLayer.eachLayer(function(layer) {
        const latlngs = layer.getLatLngs();
        if (!latlngs || !latlngs.length) return;

        const newPolygon = L.polygon(latlngs, {
          color: "#ff4444",
          weight: 2,
          fillColor: "#ff4444",
          fillOpacity: 0.6
        });

        negativeLayer.addLayer(newPolygon);
      });

      map.removeLayer(clippedBuildingsLayer);
      clippedBuildingsLayer = null;
      buildingsTransferredToExclusions = true;

      updateLawnArea();
    }

    function enterEditMode(autoStartNewPolygon = false) {
      if (!map) return;

      ensureNegativeLayer();
      transferBuildingsToExclusions();
      
      // Clear any existing draw handler from previous mode
      if (map._drawHandler) {
        map._drawHandler.disable();
        map._drawHandler = null;
      }

      if (!areaOverlay) {
        areaOverlay = L.control({ position: 'bottomleft' });
        areaOverlay.onAdd = function () {
          const div = L.DomUtil.create('div', 'leaflet-control leaflet-bar');
          div.style.cssText = `
            background: rgba(255,255,255,0.95);
            padding: 12px 18px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 3px 12px rgba(0,0,0,0.3);
          `;
          areaOverlay._div = div;
          div.innerHTML = 'Calculating...';
          return div;
        };
        areaOverlay.addTo(map);
      }

      updateLawnArea();

      if (autoStartNewPolygon) {
        document.getElementById('btn-edit-shapes').disabled = true;
        document.getElementById('btn-edit-shapes').style.opacity = '0.5';
        document.getElementById('btn-edit-shapes').style.cursor = 'not-allowed';
      } else {
        document.getElementById('btn-new-shape').disabled = true;
        document.getElementById('btn-new-shape').style.opacity = '0.5';
        document.getElementById('btn-new-shape').style.cursor = 'not-allowed';
      }

      document.getElementById('btn-finish-editing').style.display = 'inline-block';

      if (autoStartNewPolygon) {
        const newPolygonDrawer = new L.Draw.Polygon(map, {
          allowDrawingOnDrag: false,
          touchExtend: false,
          shapeOptions: {
            color: '#ff4444',
            weight: 2,
            fillColor: '#ff4444',
            fillOpacity: 0.6
          }
        });
        newPolygonDrawer.enable();
        
        // Listen for draw events with comprehensive logging
        map.on('draw:drawstart', (e) => {
          console.log('üé® [DRAW START] User started drawing polygon');
        });

        map.on('draw:drawvertex', (e) => {
          console.log('üé® [DRAW VERTEX] Vertex added to polygon');
          if (e.layer && e.layer.getLatLngs) {
            const latLngs = e.layer.getLatLngs()[0] || e.layer.getLatLngs();
            console.log(`üé® [DRAW VERTEX] Shape now has ${latLngs.length} points`);
          }
        });

        map.once('draw:created', (e) => {
          try {
            console.log('üé® [DRAW CREATED] Drawing complete!');
            const layer = e.layer;
            
            if (layer && layer.getLatLngs) {
              const latLngs = layer.getLatLngs()[0] || layer.getLatLngs();
              console.log(`üé® [DRAW CREATED] Final shape has ${latLngs.length} points`);
              
              // Log all points and check boundary
              if (parcelLayer) {
                console.log('üé® [DRAW CREATED] Parcel layer exists, checking boundaries...');
                const parcelGeoJSON = parcelLayer.toGeoJSON();
                console.log('üé® [DRAW CREATED] Parcel GeoJSON:', parcelGeoJSON);
                
                const parcelGeometry = parcelGeoJSON.features?.[0]?.geometry || parcelGeoJSON.geometry;
                if (parcelGeometry) {
                  console.log(`üé® [DRAW CREATED] Parcel geometry type: ${parcelGeometry.type}`);
                  console.log(`üé® [DRAW CREATED] Parcel coordinates length: ${JSON.stringify(parcelGeometry.coordinates).length} chars`);
                  
                  try {
                    const polygon = turf.polygon(parcelGeometry.coordinates);
                    let insideCount = 0, outsideCount = 0;
                    
                    latLngs.forEach((pt, i) => {
                      const turfPt = turf.point([pt.lng, pt.lat]);
                      const isInside = turf.booleanPointInPolygon(turfPt, polygon);
                      if (isInside) insideCount++;
                      else outsideCount++;
                      console.log(`   Point ${i}: [${pt.lat.toFixed(6)}, ${pt.lng.toFixed(6)}] ${isInside ? '‚úì INSIDE' : '‚úó OUTSIDE'}`);
                    });
                    
                    console.log(`üé® [DRAW CREATED] Boundary: ${insideCount} inside, ${outsideCount} outside`);
                    
                    if (outsideCount > 0) {
                      console.log('üé® [DRAW CREATED] Attempting to clip to boundary...');
                      try {
                        clipPolygonToParcel(layer);
                        console.log('üé® [DRAW CREATED] Clipping completed successfully');
                      } catch (err) {
                        console.error('üé® [DRAW CREATED] ERROR during clipping:', err);
                      }
                    }
                  } catch (err) {
                    console.error('üé® [DRAW CREATED] ERROR checking boundaries:', err);
                  }
                } else {
                  console.log('üé® [DRAW CREATED] No parcel geometry found');
                }
              } else {
                console.log('üé® [DRAW CREATED] No parcel layer');
              }
            }
            
            negativeLayer.addLayer(layer);
            layer.editing.enable();
            attachConstraintListeners(layer);
            updateLawnArea();
            console.log('üé® [DRAW CREATED] Shape saved and lawn area updated');
          } catch (err) {
            console.error('üé® [DRAW CREATED] CRITICAL ERROR:', err);
          }
        });

      } else {
        negativeLayer.eachLayer(layer => {
          if (layer.editing) {
            layer.editing.enable();
            attachConstraintListeners(layer);
          }
        });
      }
    }

    function finishEditing() {
      if (!map) return;

      if (map._drawHandler) {
        map._drawHandler.disable();
        map._drawHandler = null;
      }

      negativeLayer.eachLayer(layer => {
        if (layer.editing) layer.editing.disable();
      });

      if (areaOverlay) {
        areaOverlay.remove();
        areaOverlay = null;
      }

      document.getElementById('btn-finish-editing').style.display = 'none';

      const btnNew = document.getElementById('btn-new-shape');
      const btnEdit = document.getElementById('btn-edit-shapes');
      btnNew.disabled = false;
      btnEdit.disabled = false;
      btnNew.style.opacity = '1';
      btnEdit.style.opacity = '1';
      btnNew.style.cursor = 'pointer';
      btnEdit.style.cursor = 'pointer';

      updateLawnArea();
    }

    function showAerialMap(data) {
      currentData = data;
      if (!data.aerial) {
        aerialContainer.style.display = 'none';
        return;
      }
      aerialContainer.classList.remove('hidden');
      if (map) map.remove();
      map = L.map('aerial-map').setView(data.aerial.center, data.aerial.zoom);

      L.tileLayer(LINZ_AERIAL_URL, {
        attribution: '¬© <a href="https://www.linz.govt.nz/data/licensing-and-using-data/attributing-linz-data">LINZ</a> Aerial Imagery',
        maxZoom: 24,
        tileSize: 256,
        zoomOffset: 0,
        noWrap: true
      }).addTo(map);

      parcelAreaM2 = data.parcel_area_m2 || 0;
      if (data.parcel_geometry) {
        parcelLayer = L.geoJSON(data.parcel_geometry, {
          style: { color: "#0066ff", weight: 2, fillOpacity: 0 }
        }).addTo(map);
      }

      if (data.parcel_geometry && data.buildings_geometries && data.buildings_geometries.length > 0) {
        try {
          let parcelPoly;
          if (data.parcel_geometry.type === "MultiPolygon") {
            parcelPoly = turf.multiPolygon(data.parcel_geometry.coordinates);
          } else {
            parcelPoly = turf.polygon(data.parcel_geometry.coordinates);
          }
          const clippedBuildings = [];
          data.buildings_geometries.forEach(geom => {
            try {
              if (geom.type === "Polygon" && geom.coordinates && geom.coordinates.length > 0) {
                const ring = geom.coordinates[0];
                if (ring.length >= 4) {
                  const cleaned = [];
                  ring.forEach((p, i) => {
                    const prev = ring[i === 0 ? ring.length - 1 : i - 1];
                    if (i === 0 || p[0] !== prev[0] || p[1] !== prev[1]) {
                      cleaned.push(p);
                    }
                  });
                  if (cleaned.length >= 4) {
                    if (cleaned[0][0] !== cleaned[cleaned.length - 1][0] || cleaned[0][1] !== cleaned[cleaned.length - 1][1]) {
                      cleaned.push(cleaned[0]);
                    }
                    const buildingPoly = turf.polygon([cleaned]);
                    const intersection = turf.intersect(parcelPoly, buildingPoly);
                    if (intersection && intersection.geometry) {
                      clippedBuildings.push(intersection.geometry);
                    }
                  }
                }
              }
            } catch (e) {}
          });
          if (clippedBuildings.length > 0) {
            clippedBuildingsGeoJSON = { type: "FeatureCollection", features: clippedBuildings.map(g => ({ type: "Feature", geometry: g })) };
            clippedBuildingsLayer = L.geoJSON(clippedBuildings, {
              style: { color: "#ff4444", weight: 2, fillColor: "#ff4444", fillOpacity: 0.5 }
            }).addTo(map);
          }
        } catch (e) {
          console.warn('Building clipping failed', e);
        }
      }

      if (parcelLayer) {
        map.fitBounds(parcelLayer.getBounds().pad(0.2));
      }

      buildingsTransferredToExclusions = false;
      ensureNegativeLayer();
      updateLawnArea();

      document.getElementById('btn-finish-editing').style.display = 'none';

      pricingBox.classList.remove('hidden');

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      //          RESTORE EDIT MODE STATE
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (isEditMode && editingQuoteData?.mapState) {

        const ms = editingQuoteData.mapState;

        // 1. Center & zoom to saved position
        if (ms.center && ms.zoom) {
          map.setView([ms.center.lat, ms.center.lng], ms.zoom);
        }

        // 2. Add saved exclusions (negative areas) ‚Äî this is the most important part
        if (ms.negativeGeoJSON?.type === 'FeatureCollection' && ms.negativeGeoJSON.features.length > 0) {

          // We already have negativeLayer from ensureNegativeLayer()
          const exclusionLayer = L.geoJSON(ms.negativeGeoJSON, {
            style: {
              color:      "#ff4444",
              weight:     2,
              fillColor:  "#ff4444",
              fillOpacity: 0.6
            }
          });

          exclusionLayer.eachLayer(layer => {
            negativeLayer.addLayer(layer);
          });

          // Optional: make them editable right away if user came to edit
          // (or wait until they click "Edit Areas")
          // exclusionLayer.eachLayer(l => l.editing?.enable?.());
        }

        // 3. Optional: force recalculation now that exclusions are back
        updateLawnArea();

        // 4. Optional UX: show that we're using saved measurement
        if (areaOverlay?._div) {
          areaOverlay._div.innerHTML += ' <small>(from saved quote)</small>';
        }
      }
    }

    const btnNewShape = document.getElementById('btn-new-shape');
    const btnEditShapes = document.getElementById('btn-edit-shapes');
    const btnFinish = document.getElementById('btn-finish-editing');

    btnNewShape.addEventListener('click', () => {
      if (!map) {
        alert('Map not ready yet. Please load a property first.');
        return;
      }
      enterEditMode(true);
    });

    btnEditShapes.addEventListener('click', () => {
      if (!map) {
        alert('Map not ready yet. Please load a property first.');
        return;
      }
      enterEditMode(false);
    });

    btnFinish.addEventListener('click', () => {
      if (!map) {
        alert('Nothing to finish ‚Äî map not loaded.');
        return;
      }
      finishEditing();
    });

    btn.addEventListener('click', async () => {
      const address = addressInput.value.trim();
      if (!address) {
        showError("Please enter a valid address");
        return;
      }
      hideError();
      resultDiv.classList.add('hidden');
      aerialContainer.classList.add('hidden');
      pricingBox.classList.add('hidden');
      btn.disabled = true;
      btn.textContent = "Looking up...";
      btn.classList.add('loading');
      try {
        const startTime = performance.now();
        let token = null;
        if (auth.currentUser) {
          token = await auth.currentUser.getIdToken(true);
        }
        const response = await fetch(`${WORKER_URL}/api/building-area?address=${encodeURIComponent(address)}`, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            ...(token ? { 'Authorization': `Bearer ${token}` } : {})
          }
        });
        const text = await response.text();
        let data;
        try {
          data = JSON.parse(text);
        } catch {
          throw new Error("Invalid response from server");
        }
        const timeTaken = ((performance.now() - startTime) / 1000).toFixed(1);
        if (!response.ok || data.error) {
          throw new Error(data.error || "Service error");
        }
        addressDisplay.textContent = data.address;
        areaDisplay.textContent = `${data.estimated_lawn_area_m2?.toLocaleString() || 'Calculating...'} m¬≤`;
        timeDisplay.textContent = `Found in ${timeTaken} seconds`;
        resultDiv.classList.remove('hidden');
        showAerialMap(data);
        
        // Hide loading splash when data is loaded
        if (loadingSplash) {
          loadingSplash.classList.add('fade-out');
          setTimeout(() => loadingSplash.style.display = 'none', 500);
        }
      } catch (err) {
        showError(err.message || "Failed to fetch data");
        // Hide splash on error too
        if (loadingSplash) {
          loadingSplash.classList.add('fade-out');
          setTimeout(() => loadingSplash.style.display = 'none', 500);
        }
      } finally {
        btn.disabled = false;
        btn.textContent = "Search Property";
        btn.classList.remove('loading');
      }
    });

    addressInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') btn.click();
    });

    function showError(msg) {
      errorDiv.textContent = msg;
      errorDiv.classList.remove('hidden');
    }

    function hideError() {
      errorDiv.classList.add('hidden');
      errorDiv.textContent = '';
    }

    document.getElementById('generate-pdf-btn').addEventListener('click', async () => {
      if (!currentData || currentLawnArea === 0) {
        alert('Please load an address and measure the lawn area first.');
        return;
      }
      if (!auth.currentUser) {
        alert('Please sign in to save quotes');
        window.location.href = 'login.html';
        return;
      }

      const token = await auth.currentUser.getIdToken();

      let companyProfile = {};
      try {
        const profileRes = await fetch(`${WORKER_URL}/api/user/profile`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (profileRes.ok) {
          const { profile } = await profileRes.json();
          companyProfile = {
            companyName: profile.companyName || 'Deep Edge',
            nzbn: profile.nzbn || '',
            phone: profile.phone || '',
            gstNumber: profile.gstNumber || '',
            email: profile.email || '',
            logoUrl: profile.logoUrl || ''
          };
        }
      } catch (e) {
        console.warn('Could not fetch company profile for quote', e);
      }

      const negativeGeoJSON = negativeLayer ? negativeLayer.toGeoJSON() : { type: "FeatureCollection", features: [] };

      const totalInclText = document.getElementById('total-incl')?.textContent || '$0.00';
      const totalInclGst = parseFloat(totalInclText.replace('$', '').replace(',', '')) || 0;

      let quoteNumber = document.getElementById('quote-number')?.value?.trim() || '';
      if (!quoteNumber) {
          const year = new Date().getFullYear();
          const timestampPart = Date.now().toString().slice(-6);
          quoteNumber = `Q-${year}-${timestampPart}`;
      }

      const quoteData = {
        quoteNumber: quoteNumber,
        address: addressDisplay.textContent,
        lawnAreaM2: currentLawnArea,
        calloutFee: parseFloat(calloutInput.value) || 0,
        difficultyMultiplier: parseFloat(difficultySlider.value),
        catchAndMulch: catchMulchCheckbox.checked,
        estimatedHours: parseFloat(estimatedJobTimeInput.value) || 0,
        totalInclGst: totalInclGst,
        client: loadedJobData?.client ? {
          firstName: loadedJobData.client.firstName || '',
          lastName: loadedJobData.client.lastName || ''
        } : {},
        company: companyProfile,
        mapState: {
          center: map.getCenter(),
          zoom: map.getZoom(),
          parcelGeometry: currentData.parcel_geometry,
          buildingsGeoJSON: clippedBuildingsGeoJSON,
          negativeGeoJSON: negativeGeoJSON
        },
        generatedAt: new Date().toISOString(),
        jobId: jobId || null,
        mowerType: getSelectedMowerType()
      };

      try {
        const isUpdate = isEditMode && editingQuoteId;
        const method   = isUpdate ? 'PATCH' : 'POST';
        const url      = isUpdate 
          ? `${WORKER_URL}/api/quotes/${editingQuoteId}`
          : `${WORKER_URL}/api/quotes`;

        const res = await fetch(url, {
          method: method,
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(quoteData)
        });

        if (!res.ok) {
          const errText = await res.text();
          throw new Error(errText || (isUpdate ? 'Failed to update quote' : 'Failed to save quote'));
        }

        let quoteIdReturned;
        if (isUpdate) {
          // For PUT/update your backend might return 200/204 with no body,
          // or return the updated quote object ‚Äî handle both cases
          quoteIdReturned = editingQuoteId;
          // Optional: if your PUT returns the full updated quote, you could do:
          // const updated = await res.json();
          // quoteIdReturned = updated.id || editingQuoteId;
        } else {
          const data = await res.json();
          quoteIdReturned = data.quoteId;   // assuming your POST returns { quoteId: "..." }
        }

        const publicLink = `${window.location.origin}/roof/quote.html?quote=${quoteIdReturned}`;

        document.getElementById('quote-link').href = publicLink;
        document.getElementById('quote-link').textContent = publicLink;
        document.getElementById('quote-link-box').classList.remove('hidden');

        alert(isUpdate 
          ? `Quote updated successfully!\n\nShare this link with your client:\n${publicLink}`
          : `Quote saved successfully!\n\nShare this link with your client:\n${publicLink}`
        );

        const targetJobId = jobId || (editingQuoteData?.jobId);
        if (targetJobId) {
          setTimeout(() => {
            window.location.href = `jobs.html?jobId=${targetJobId}`;
          }, 1800);
        }

      } catch (err) {
        console.error('Quote save failed:', err);
        alert('Failed to save quote: ' + err.message);
      }
    });

    const suggestionsBox = document.getElementById("address-suggestions");
    let debounceTimer = null;

    addressInput.addEventListener("input", (e) => {
      const value = e.target.value.trim();

      clearTimeout(debounceTimer);

      if (value.length < 3) {
        hideSuggestions();
        return;
      }

      debounceTimer = setTimeout(() => {
        fetchSuggestions(value);
      }, 250);
    });

    async function fetchSuggestions(query) {
      try {
        const res = await fetch(
          `${WORKER_URL}/api/address-suggest?q=${encodeURIComponent(query)}`
        );

        if (!res.ok) return;

        const data = await res.json();
        renderSuggestions(data.addresses || []);
      } catch (err) {
        console.warn("Suggest failed", err);
      }
    }

    function renderSuggestions(addresses) {
      suggestionsBox.innerHTML = "";

      if (!addresses.length) {
        hideSuggestions();
        return;
      }

      addresses.forEach(addr => {
        const div = document.createElement("div");
        div.className = "suggestion-item";
        div.textContent = addr.FullAddress;

        div.addEventListener("click", () => {
          addressInput.value = addr.FullAddress;
          hideSuggestions();
        });

        suggestionsBox.appendChild(div);
      });

      suggestionsBox.classList.remove("hidden");
    }

    function hideSuggestions() {
      suggestionsBox.classList.add("hidden");
      suggestionsBox.innerHTML = "";
    }

    document.addEventListener("click", (e) => {
      if (!e.target.closest(".input-group")) {
        hideSuggestions();
      }
    });

  </script>
</body>
</html>