<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Jobs ‚Ä¢ Deep Edge (Dynamic Job Flow - Light Mode)</title>
 
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <script src="sms.js" defer></script>
  <link rel="stylesheet" href="./index-FsI4UGjo.css">
  <script src="header.js" defer></script>
 
  <style>
    :root {
      --background: 270 30% 97%;
      --foreground: 245 35% 15%;
      --card: 0 0% 100%;
      --card-foreground: 245 35% 15%;
      --primary: 288 52% 36%;
      --primary-foreground: 0 0% 100%;
      --secondary: 270 20% 96%;
      --muted: 270 20% 96%;
      --muted-foreground: 245 10% 45%;
      --accent: 288 52% 36%;
      --accent-foreground: 0 0% 100%;
      --border: 245 20% 88%;
      --input: 245 20% 88%;
      --ring: 288 52% 36%;
      --radius: 1.75rem;
      --green: #10b981;
      --green-dark: #059669;
      --yellow: #d97706;
      --blue: #2563eb;
      --red: #dc2626;
      --shadow: 0 24px 70px rgba(27, 27, 47, 0.12);
      --modal-bg: rgba(0,0,0,0.65);
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: 'Inter', 'Manrope', system-ui, -apple-system, sans-serif;
      background-color: hsl(var(--background));
      color: hsl(var(--foreground));
      min-height: 100vh;
      padding: 20px 16px;
      padding-top: calc(5rem + 20px);
      line-height: 1.45;
      overflow-x: hidden;
    }
    h1, h2, h3, h4, h5, h6 {
      font-family: 'Space Grotesk', 'Manrope', system-ui, -apple-system, sans-serif;
      letter-spacing: -0.02em;
      line-height: 0.98;
    }
    .container { max-width: 960px; margin: 0 auto; }
    .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 32px;
        margin-top: 0px;
        flex-wrap: wrap;
        gap: 16px;
    }
    h1 { font-size: 2.25rem; font-weight: 800; color: #7B2D8E; letter-spacing: -0.5px; }
    .btn-new {
      background: #7B2D8E;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 50px;
      font-weight: 600;
      font-size: 0.98rem;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(123, 45, 142, 0.2);
    }
    .btn-new:hover { background: #662375; transform: translateY(-1px); box-shadow: 0 6px 20px rgba(123, 45, 142, 0.3); }
    .job-card {
      background: hsl(var(--card));
      border: 1px solid hsl(var(--border));
      border-radius: var(--radius);
      padding: 22px;
      margin-bottom: 32px;
      position: relative;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
    }
    .job-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 16px 40px rgba(123, 45, 142, 0.15);
    }
    .job-address {
      font-size: 1.15rem;
      font-weight: 700;
      color: #7B2D8E;
      margin-bottom: 6px;
    }
    .job-client {
      font-size: 1.08rem;
      color: hsl(var(--muted-foreground));
      margin-bottom: 14px;
    }
    .meta {
      display: flex;
      flex-wrap: wrap;
      gap: 16px 24px;
      margin-bottom: 16px;
      font-size: 0.94rem;
      color: hsl(var(--muted-foreground));
    }
    .status-badge {
      padding: 6px 14px;
      border-radius: 999px;
      font-weight: 600;
      font-size: 0.88rem;
    }
    .status-create_quote { background: rgba(123, 45, 142, 0.1); color: #7B2D8E; }
    .status-created { background: rgba(123, 45, 142, 0.1); color: #7B2D8E; }
    .status-quoted { background: rgba(123, 45, 142, 0.15); color: #7B2D8E; }
    .status-won { background: #ecfdf5; color: #059669; }
    .status-progress { background: #fffbeb; color: #d97706; }
    .status-completed { background: #f0fdf4; color: #059669; }
    .status-invoiced { background: #eff6ff; color: #2563eb; }
    .status-paid { background: #f0fdf4; color: #059669; }
    .status-pending-service { background: #fef3c7; color: #d97706; }
    .last-activity {
      font-style: normal;
      color: hsl(var(--muted-foreground));
      font-weight: 500;
    }
    .primary-action {
        display: block;
        width: 100%;
        max-width: 300px;
        margin: 24px auto;
        padding: 16px 20px;
        background: var(--green);
        color: white;
        border: none;
        border-radius: 50px;
        font-size: 1.14rem;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.25s;
        box-shadow: 0 5px 16px rgba(16, 185, 129, 0.25);
    }
    .primary-action:hover {
      background: var(--green-dark);
      transform: translateY(-2px);
    }
    .overflow {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 1.9rem;
      color: hsl(var(--muted-foreground));
      cursor: pointer;
      user-select: none;
      z-index: 5;
    }
    .menu {
      position: absolute;
      top: 50px;
      right: 0;
      background: hsl(var(--card));
      border: 1px solid hsl(var(--border));
      border-radius: 12px;
      min-width: 240px;
      box-shadow: 0 12px 36px rgba(0,0,0,0.15);
      z-index: 10;
      display: none;
      overflow: hidden;
    }
    .menu.show { display: block; }
    .menu-section { padding: 6px 0; }
    .menu-item {
      padding: 12px 20px;
      cursor: pointer;
      transition: background 0.15s;
      color: hsl(var(--foreground));
      font-size: 0.95rem;
    }
    .menu-item.menu-disabled {
      color: #9ca3af;
      cursor: default;
    }
    .menu-item:hover { background: hsl(var(--secondary)); }
    .menu-danger {
      color: var(--red);
      border-top: 1px solid hsl(var(--border));
    }
    .menu-danger:hover { background: #fee2e2; }
    .progress-bar {
      height: 6px;
      background: hsl(var(--border));
      border-radius: 3px;
      margin: 18px 0 22px;
      overflow: hidden;
    }
    .progress-fill {
      height: 100%;
      background: #7B2D8E;
      width: 0;
      transition: width 0.6s ease;
    }
    .notes-preview {
      margin-top: 16px;
      padding: 12px;
      background: hsl(var(--secondary));
      border-radius: 8px;
      font-size: 0.92rem;
      color: hsl(var(--muted-foreground));
      line-height: 1.4;
      cursor: pointer;
      border: 1px solid hsl(var(--border));
      transition: all 0.25s;
    }
    .notes-preview:hover { background: hsl(var(--border)); }
    .notes-expanded {
      margin-top: 16px;
      display: none;
    }
    .notes-expanded.open {
      display: block;
    }
    .notes-textarea {
      width: 100%;
      padding: 12px;
      border: 1px solid hsl(var(--border));
      border-radius: 8px;
      font-family: 'Manrope', system-ui, -apple-system, sans-serif;
      font-size: 0.92rem;
      color: hsl(var(--foreground));
      resize: vertical;
      min-height: 120px;
      line-height: 1.4;
      box-sizing: border-box;
    }
    .notes-textarea:focus {
      outline: none;
      border-color: #7B2D8E;
      box-shadow: 0 0 0 2px rgba(123, 45, 142, 0.1);
    }
    .notes-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }
    .btn-save-notes, .btn-cancel-notes {
      flex: 1;
      padding: 10px 16px;
      border: none;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn-save-notes {
      background: #7B2D8E;
      color: white;
    }
    .btn-save-notes:hover {
      background: #662375;
    }
    .btn-cancel-notes {
      background: hsl(var(--border));
      color: hsl(var(--foreground));
    }
    .btn-cancel-notes:hover {
      background: #d1d5db;
    }
    .activity-expanded {
      margin-top: 16px;
      display: none;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid hsl(var(--border));
      border-radius: 8px;
      background: hsl(var(--secondary));
      padding: 12px;
    }
    .activity-expanded.open {
      display: block;
    }
    .activity-item {
      padding: 10px;
      border-bottom: 1px solid hsl(var(--border));
      font-size: 0.9rem;
    }
    .activity-item:last-child {
      border-bottom: none;
    }
    .activity-timestamp {
      font-weight: 600;
      color: #7B2D8E;
      font-size: 0.85rem;
    }
    .activity-action {
      color: hsl(var(--muted-foreground));
      margin-top: 4px;
      line-height: 1.4;
    }
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: var(--modal-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.25s;
    }
    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    .modal-content {
      background: hsl(var(--card));
      border-radius: 16px;
      width: 90%;
      max-width: 420px;
      padding: 28px;
      box-shadow: var(--shadow);
      transform: translateY(30px);
      transition: transform 0.3s;
    }
    .modal-overlay.active .modal-content {
      transform: translateY(0);
    }
    .modal-title {
      font-size: 1.4rem;
      font-weight: 700;
      margin-bottom: 20px;
      color: hsl(var(--foreground));
    }
    .modal-select, .modal-input {
      width: 100%;
      padding: 12px 16px;
      margin-bottom: 16px;
      border: 1px solid hsl(var(--border));
      border-radius: 10px;
      font-size: 1rem;
      background: hsl(var(--secondary));
    }
    .modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 20px;
    }
    .btn-modal {
      padding: 12px 24px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      border: none;
    }
    .btn-cancel {
      background: hsl(var(--border));
      color: hsl(var(--foreground));
    }
    .btn-primary-modal {
      background: var(--green);
      color: white;
    }
    .btn-send {
      background: #7B2D8E;
      color: white;
      flex: 1;
    }
    .send-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 16px;
    }
    @media (max-width: 500px) {
      .primary-action { font-size: 1.04rem; padding: 14px 18px; }
      .job-address { font-size: 1.32rem; }
      .modal-content { padding: 24px; }
      .menu { min-width: 200px; right: 10px; }
    }
    /* New styles for added elements */
    h2 { font-size: 1.75rem; font-weight: 700; margin-bottom: 20px; color: hsl(var(--foreground)); }
    .today-previews {
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin-bottom: 48px;
    }
    .mini-card {
        background: hsl(var(--card));
        border: 1px solid hsl(var(--border));
        border-radius: var(--radius);
        padding: 16px 20px;
        transition: all 0.3s ease;
        /* width: 100%; */
        max-width: 960px;
        margin: 0 auto 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 20px;
        margin: 10px;
    }

    .mini-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 24px rgba(123, 45, 142, 0.1);
    }
    .mini-left {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }
    .mini-address-line {
      font-size: 1.15rem;
      font-weight: 700;
      color: #7B2D8E;
      line-height: 1.2;
    }
    .mini-suburb {
      font-size: 1.15rem;
      font-weight: 700;
      color: #7B2D8E;
      line-height: 1.2;
    }
    .mini-activity {
      font-size: 0.82rem;
      color: hsl(var(--muted-foreground));
      margin-top: 4px;
      line-height: 1.3;
    }
    .mini-right {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 6px;
        /* min-width: 140px; */
        flex-shrink: 0;
    }
    .mini-status {
        padding: 6px 16px;
        border-radius: 24px;
        font-weight: 600;
        font-size: 0.88rem;
        /* letter-spacing: 0.3px; */
    }
    .mini-value {
        font-size: 1.6rem;
        font-weight: 700;
        color: var(--green);
    }
    @media (max-width: 640px) {
      .mini-card { flex-direction: column; align-items: flex-start; gap: 12px; }
      .mini-right { width: 100%; flex-direction: row; justify-content: space-between;}
      .mini-value { font-size: 1.15rem; }
    }
    .calendar {
      background: hsl(var(--card));
      border: 1px solid hsl(var(--border));
      border-radius: var(--radius);
      padding: 10px;
      margin-bottom: 48px;
      box-shadow: var(--shadow);
      overflow-x: auto;
    }
    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 8px;
      min-width: 100%;
    }
    .calendar-day {
      padding: 12px 8px;
      text-align: center;
      border: 1px solid hsl(var(--border));
      border-radius: 8px;
      font-size: 0.85rem;
      min-height: 60px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .calendar-day:hover {
      background: hsl(var(--secondary));
    }
    .calendar-day.today {
      border: 2px solid #7B2D8E;
      background: rgba(123, 45, 142, 0.08);
    }
    .calendar-day.header {
      font-weight: 600;
      background: hsl(var(--secondary));
      min-height: auto;
      padding: 8px;
      cursor: default;
    }
    .calendar-day.header:hover {
      background: hsl(var(--secondary));
    }
    .calendar-day.past {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    }
    .calendar-day.past:hover {
      background: hsl(var(--secondary));
    }
    .calendar-day-number {
      font-weight: 600;
      color: var(--text);
      margin-bottom: 4px;
    }
    .calendar-counter {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: #7B2D8E;
      color: white;
      font-weight: 700;
      font-size: 0.85rem;
    }
    .search-container {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }
    .search-input {
      flex: 1;
      min-width: 200px;
      padding: 12px 16px;
      border: 1px solid hsl(var(--border));
      border-radius: 10px;
      font-size: 0.98rem;
      background: hsl(var(--card));
      color: hsl(var(--foreground));
      font-family: 'Manrope', system-ui, -apple-system, sans-serif;
      transition: all 0.2s ease;
    }
    .search-input:focus {
      outline: none;
      border-color: #7B2D8E;
      box-shadow: 0 0 0 3px rgba(123, 45, 142, 0.1);
    }
    .search-input::placeholder {
      color: hsl(var(--muted-foreground));

    }
    @media (max-width: 600px) {
      .calendar-grid {
        gap: 4px;
      }
      .calendar-day {
        padding: 8px 4px;
        min-height: 50px;
        font-size: 0.75rem;
      }
      .calendar-counter {
        width: 24px;
        height: 24px;
        font-size: 0.75rem;
      }
    }
    .all-jobs {
      margin-bottom: 48px;
    }
    @keyframes slideDown {
      from {
        transform: translateY(-20px);
      }
      to {
        transform: translateY(0);
      }
    }
    @keyframes slideUp {
      from {
        transform: translateY(0);
      }
      to {
        transform: translateY(-20px);
      }
    }
    .job-card-expanded {
      border: 2px solid #7B2D8E;
      box-shadow: 0 16px 40px rgba(123, 45, 142, 0.15);
    }
    /* Loading splash screen */
    #loading-splash {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: hsl(var(--background));
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 1;
      visibility: visible;
      transition: opacity 0.5s ease, visibility 0.5s ease;
    }
    #loading-splash.fade-out {
      opacity: 0;
      visibility: hidden;
    }
    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid #e5e7eb;
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: 20px;
    }
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
    #loading-splash p {
      font-size: 1.1rem;
      color: var(--muted);
      font-weight: 500;
    }
    /* Dropdown sections for On-Site and Admin */
    .jobs-section {
      margin-bottom: 24px;
    }
    .jobs-section details {
      background: var(--card);
    }
    .jobs-section summary {
      list-style: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      user-select: none;
    }
    .jobs-section summary::-webkit-details-marker {
      display: none;
    }
    .jobs-section summary::after {
      content: '‚ñº';
      display: inline-block;
      transition: transform 0.3s ease;
      font-size: 0.75rem;
      color: var(--muted);
      flex-shrink: 0;
    }
    .jobs-section details[open] summary::after {
      transform: rotate(-90deg);
    }
    .jobs-section summary h3 {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--muted);
      margin: 0;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .jobs-section-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: var(--accent);
      color: white;
      font-weight: 700;
      font-size: 0.85rem;
    }
    .jobs-section-content {
      animation: slideDown 0.3s ease;
    }
    #route-apple-maps-btn-today {
      align-self: flex-end;
      margin-left: auto;
      margin-right: 0;
      width: auto;
    }
    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    /* Navigation */
    nav {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 100;
        transition: all 0.3s ease;
        padding: 0 1.5rem;
        height: 5rem;
    }
    nav.scrolled {
        background-color: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(16px);
        box-shadow: 0 1px 3px rgba(27, 27, 47, 0.1);
    }
    nav.not-scrolled {
        background-color: transparent;
    }
    nav .container {
        display: flex;
        align-items: center;
        justify-content: space-between;
        height: 100%;
        max-width: 1280px;
        margin: 0 auto;
    }
    .nav-logo {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        text-decoration: none;
        color: #1B1B2F;
    }
    .nav-logo-icon {
        width: 1.75rem;
        height: 1.75rem;
        background-color: #7B2D8E;
        border-radius: 0.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 0.75rem;
    }
    .nav-logo-text {
        font-weight: 600;
        font-size: 1rem;
        letter-spacing: -0.025em;
    }
    .nav-menu-desktop {
        display: none;
        gap: 2rem;
        align-items: center;
    }
    @media (min-width: 1024px) {
        .nav-menu-desktop {
            display: flex;
        }
        .nav-menu-mobile {
            display: none !important;
        }
    }
    .nav-link {
        background: none;
        border: none;
        color: #6E6E82;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: color 0.3s ease;
    }
    .nav-link:hover {
        color: #1B1B2F;
    }
    .button-primary {
        background-color: #7B2D8E;
        color: white;
        padding: 0.75rem 1.5rem;
        border-radius: 9999px;
        border: none;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    .button-primary:hover {
        background-color: #662375;
        box-shadow: 0 8px 16px rgba(123, 45, 142, 0.3);
    }
    /* Mobile menu */
    .mobile-menu {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 99;
    }
    .mobile-menu.open {
        display: block;
    }
    .mobile-menu-panel {
        position: absolute;
        top: 5rem;
        left: 0;
        right: 0;
        background: white;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .mobile-menu-panel button {
        display: block;
        width: 100%;
        text-align: left;
        padding: 1rem 1.5rem;
        border: none;
        background: none;
        font-weight: 500;
        color: #1B1B2F;
        cursor: pointer;
        font-size: 1rem;
        transition: background-color 0.2s ease;
    }
    .mobile-menu-panel button:hover {
        background-color: #f3f4f6;
    }
    .grain-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0.04;
        mix-blend-mode: multiply;
        z-index: 9999;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
    }
    section {
        scroll-margin-top: 5rem;
    }
  </style>
</head>
<body>
  <div class="grain-overlay"></div>

  <!-- Loading Splash Screen -->
  <div id="loading-splash" style="display: none;">
    <div class="spinner"></div>
    <p>Loading your jobs...</p>
  </div>

<div class="container">
  <div class="header">
    <h1>Your Jobs</h1>
    <div style="display: flex; gap: 12px;">
      <a href="#" class="btn-new" onclick="window.location.href='create_job.html'; return false;">
        + New Job
      </a>
      <button id="load-mock-data-btn" style="background: #8b5cf6; color: white; border: none; padding: 12px 24px; border-radius: 50px; font-weight: 600; font-size: 0.98rem; cursor: pointer; box-shadow: 0 2px 8px rgba(139,92,246,0.2);" onmouseover="this.style.background='#7c3aed'" onmouseout="this.style.background='#8b5cf6'">
        üìã Load Mock Data (Test)
      </button>
    </div>
  </div>
  <h2>Today</h2>
  <div class="today-previews">
    <!-- Dynamic today's jobs will be inserted here -->
  </div>
  <h2>Calendar</h2>
  <div class="calendar" id="calendarContainer">
    <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px; justify-content: center;">
      <button id="prevMonthBtn" style="padding: 6px 12px; background: var(--accent); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">‚Üê Prev</button>
      <span id="calendarMonth" style="min-width: 150px; text-align: center; font-weight: 600;"></span>
      <button id="nextMonthBtn" style="padding: 6px 12px; background: var(--accent); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Next ‚Üí</button>
    </div>
    <div class="calendar-grid" id="calendarGrid">
      <!-- Generated dynamically -->
    </div>
  </div>
  <div style="display: flex; align-items: center; gap: 16px; flex-wrap: wrap; margin-bottom: 20px;">
    <h2 style="margin-bottom: 0;">All Jobs</h2>
    <div class="search-container" style="margin-bottom: 0; flex: 1;">
      <input type="text" id="jobSearch" class="search-input" placeholder="Search jobs (address, client, phone, etc)...">
    </div>
  </div>
  <div class="all-jobs" id="jobs-container">
    <!-- Dynamic jobs will be inserted here -->
  </div>
</div>
<div id="modalOverlay" class="modal-overlay">
  <div class="modal-content" id="modalContent"></div>
</div>
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
import { getAuth } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
let mockJobsData = {};
const firebaseConfig = {
  apiKey: "AIzaSyAzS6a2JbgFxSJLPi2-sWyflOfrE7jd73g",
  authDomain: "deep-edge-cc5bd.firebaseapp.com",
  projectId: "deep-edge-cc5bd",
  storageBucket: "deep-edge-cc5bd.firebasestorage.app",
  messagingSenderId: "23198790796",
  appId: "1:23198790796:web:616de764b8a8db2ae1f7a9"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const WORKER_URL = "https://firebase-protected-backend.jamesisarad.workers.dev";

// ‚îÄ‚îÄ Toast Notification Function ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function showToast(message, type = 'info') {
  const toastContainer = document.getElementById('toast-container') || (() => {
    const container = document.createElement('div');
    container.id = 'toast-container';
    container.style.cssText = 'position: fixed; top: 100px; right: 20px; z-index: 10000; display: flex; flex-direction: column; gap: 10px;';
    document.body.appendChild(container);
    return container;
  })();

  const toast = document.createElement('div');
  toast.style.cssText = `
    padding: 14px 16px;
    border-radius: 8px;
    font-weight: 500;
    font-size: 14px;
    max-width: 300px;
    white-space: pre-wrap;
    word-break: break-word;
    animation: slideIn 0.3s ease-out;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  `;

  if (type === 'success') {
    toast.style.backgroundColor = '#10b981';
    toast.style.color = 'white';
  } else if (type === 'error') {
    toast.style.backgroundColor = '#dc2626';
    toast.style.color = 'white';
  } else {
    toast.style.backgroundColor = '#2563eb';
    toast.style.color = 'white';
  }

  toast.textContent = message;
  toastContainer.appendChild(toast);

  setTimeout(() => {
    toast.style.animation = 'slideOut 0.3s ease-out';
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}

// Add animation styles if not already present
if (!document.getElementById('toast-styles')) {
  const style = document.createElement('style');
  style.id = 'toast-styles';
  style.textContent = `
    @keyframes slideIn {
      from { transform: translateX(400px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slideOut {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(400px); opacity: 0; }
    }
  `;
  document.head.appendChild(style);
}

// ‚îÄ‚îÄ STATUS UPDATE HELPER - Any change triggers full jobs reload ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function updateJobAndReload(jobId, updatePayload, card) {
  // Show optimistic feedback immediately
  if (updatePayload.status) {
    card.dataset.stage = updatePayload.status;
    updateCard(card);
  }
  showToast(`Updating...`);

  try {
    // Send update to backend
    const token = await auth.currentUser.getIdToken();
    const response = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(updatePayload)
    });

    if (!response.ok) {
      throw new Error('Server update failed');
    }
    
    // CRUCIAL: After ANY change, reload ALL jobs and re-render
    // This ensures all interdependencies and visuals are updated correctly
    await loadAndRenderJobs();
    showToast(`Updated successfully!`, 'success');
    console.log(`‚úì Job updated and all jobs reloaded: ${jobId}`);
    
  } catch (err) {
    showToast(`Update failed: ${err.message}`, 'error');
    console.error(`‚úó Update failed for ${jobId}:`, err);
    // Don't revert UI - just let user know it failed
    // Next sync will pull fresh data from backend
  }
}

// ‚îÄ‚îÄ PERIODIC SYNC (Every 5 minutes) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function startPeriodicSync() {
  setInterval(async () => {
    try {
      const token = await auth.currentUser.getIdToken();
      const jobs = document.querySelectorAll('[data-job-id]');
      
      for (const jobCard of jobs) {
        const jobId = jobCard.dataset.jobId;
        const response = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (!response.ok) continue;
        
        const data = await response.json();
        const job = data.job || data;
        
        // Update if server status differs from local (or other critical fields)
        if (job.status && job.status !== jobCard.dataset.stage) {
          console.log(`üîÑ Status drift detected for ${jobId}: local=${jobCard.dataset.stage} server=${job.status}`);
          
          // Update all card attributes with fresh server data to ensure consistency
          jobCard.dataset.stage = job.status;
          jobCard.dataset.isRecurring = job.isRecurring ? 'true' : 'false';
          jobCard.dataset.recurrence = job.recurrence || '';
          jobCard.dataset.nextServiceDate = job.nextServiceDate || '';
          jobCard.dataset.quoteId = job.activeQuoteId || '';
          
          // Re-render card with all fresh data
          updateCard(jobCard);
          showToast(`${jobCard.dataset.jobName} status synced: ${job.status}`, 'info');
        }
      }
    } catch (err) {
      console.log('Periodic sync check completed (errors are OK)', err.message);
    }
  }, 5 * 60 * 1000); // Every 5 minutes
}
// ‚îÄ‚îÄ STAGES config (kept as-is) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const STAGES = [
  {
    id: 'lead',
    label: 'Lead',
    color: 'status-create_quote',
    progress: 7.145,
    primary: 'Create Quote',
    lastActivity: 'Quote Deleted',
    menuItems: [
      { text: 'View Details', action: 'view-details', danger: false },
      { text: 'Cancel Job', action: 'cancel-job', danger: true }
    ]
  },
  {
    id: 'quoted',
    label: 'Quote Created',
    color: 'status-created',
    progress: 14.29,
    primary: 'Send Quote',
    lastActivity: 'Quote created',
    menuItems: [
      { text: 'Edit Quote', action: 'edit-quote', danger: false },
      { text: 'View Details', action: 'view-details', danger: false },
      { text: 'Delete Quote', action: 'delete-quote', danger: true }
    ]
  },
  {
    id: 'quoteSent',
    label: 'Quote Sent',
    color: 'status-quoted',
    progress: 28.57,
    primary: 'Schedule Service',
    lastActivity: 'Quote sent to client',
    menuItems: [
      { text: 'Resend Quote', action: 'resend-quote', danger: false },
      { text: 'Edit Quote', action: 'edit-quote', danger: false },
      { text: 'Change Price', action: 'change-price', danger: false },
      { text: 'View Details', action: 'view-details', danger: false },
      { text: 'Cancel Job', action: 'cancel-job', danger: true }
    ]
  },
  {
    id: 'won',
    label: 'Job Won',
    color: 'status-won',
    progress: 42.86,
    primary: 'Start Job',
    lastActivity: 'Job accepted by client',
    menuItems: [
      { text: 'Change Schedule', action: 'schedule-visit', danger: false },
      { text: 'Adjust Price', action: 'adjust-price', danger: false },
      { text: 'View Details', action: 'view-details', danger: false },
      { text: 'Cancel Service', action: 'cancel-service', danger: true }
    ]
  },
  {
    id: 'progress',
    label: 'In Progress',
    color: 'status-progress',
    progress: 57.14,
    primary: 'Complete Job',
    lastActivity: 'Service started on site',
    menuItems: [
      { text: 'Add Photo', action: 'add-photo', danger: false },
      { text: 'Skip Visit', action: 'skip-visit', danger: false },
      { text: 'Adjust Price', action: 'adjust-price', danger: false },
      { text: 'Change Frequency', action: 'change-freq', danger: false },
      { text: 'View Details', action: 'view-details', danger: false },
      { text: 'Cancel Service', action: 'cancel-service', danger: true }
    ]
  },
  {
    id: 'completed',
    label: 'Completed',
    color: 'status-completed',
    progress: 71.43,
    primary: 'Create Invoice',
    lastActivity: 'Job completed',
    menuItems: [
      { text: 'Adjust Final Price', action: 'adjust-final-price', danger: false },
      { text: 'View Details', action: 'view-details', danger: false },
      { text: 'Reopen Job', action: 'reopen-job', danger: true }
    ]
  },
  {
    id: 'invoiced',
    label: 'Invoiced',
    color: 'status-invoiced',
    progress: 85.71,
    primary: 'Mark Paid',
    lastActivity: 'Invoice sent',
    menuItems: [
      { text: 'View Invoice', action: 'view-invoice', danger: false },
      { text: 'Edit Invoice', action: 'edit-invoice', danger: false },
      { text: 'View Details', action: 'view-details', danger: false },
      { text: 'Void Invoice', action: 'void-invoice', danger: true }
    ]
  },
  {
    id: 'paid',
    label: 'Paid ‚úì',
    color: 'status-paid',
    progress: 100,
    primary: 'Schedule Next Visit', // default - will be overridden in updateCard for one-off
    lastActivity: 'Payment received',
    menuItems: [
      { text: 'Send Receipt', action: 'send-receipt', danger: false },
      { text: 'View History', action: 'view-history', danger: false },
      { text: 'View Details', action: 'view-details', danger: false },
      { text: 'Archive Client', action: 'archive-client', danger: true }
    ]
  },
  {
    id: 'pendingService',
    label: 'Pending Service',
    color: 'status-pending-service',
    progress: 42.86,
    primary: 'Start Service',
    lastActivity: 'Service pending',
    menuItems: [
      { text: 'Change Schedule', action: 'schedule-visit', danger: false },
      { text: 'View Details', action: 'view-details', danger: false },
      { text: 'Skip This Visit', action: 'skip-visit', danger: false }
    ]
  }
];
// ‚îÄ‚îÄ mockQuotes (kept as-is for invoice modal) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const mockQuotes = [
  { id: 'Q-1021', date: '2026-01-10', total: 285.50 },
  { id: 'Q-1018', date: '2025-12-22', total: 260.00 },
  { id: 'Q-1012', date: '2025-11-30', total: 240.75 }
];
// ‚îÄ‚îÄ Updated updateCard with recurring logic ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateCard(card) {
  const stage = card.dataset.stage || 'created';
  const isRecurring = card.dataset.isRecurring === 'true';

  // Find base config
  let config = STAGES.find(s => s.id === stage) || STAGES[0];

  // Special override for paid stage
  let primaryText = config.primary;
  let btnColor = "var(--green)";  // default active
  let isDisabled = false;

  if (stage === 'paid') {
    if (isRecurring) {
      primaryText = "Schedule Next Visit";
      btnColor = "var(--green)";      // active / encouraging
      isDisabled = false;
    } else {
      primaryText = "Job Complete";
      btnColor = "var(--green-dark)"; // final / subdued
      isDisabled = true;
    }
  }
  
  if (stage === 'pendingService') {
    primaryText = "Start Service";
    btnColor = "var(--green)";        // active / encouraging
    isDisabled = false;
  }

  // Apply to button
  const primaryBtn = card.querySelector('.primary-action');
  if (primaryBtn) {
    primaryBtn.textContent = primaryText;
    primaryBtn.style.background = btnColor;
    primaryBtn.disabled = isDisabled;
  }

  // Badge
  const badge = card.querySelector('.status-badge');
  if (badge) {
    badge.textContent = config.label;
    badge.className = `status-badge ${config.color}`;
  }

  // Last activity
  const lastActivity = card.querySelector('.last-activity');
  if (lastActivity) {
    lastActivity.textContent = `Last activity: ${config.lastActivity}`;
  }

  // Progress bar
  const progressFill = card.querySelector('.progress-fill');
  if (progressFill) {
    progressFill.style.width = `${config.progress}%`;
  }

  // Rebuild menu
  const menu = card.querySelector('.menu');
  if (menu) {
    menu.innerHTML = '';
    const section = document.createElement('div');
    section.className = 'menu-section';
    config.menuItems.forEach(item => {
      // Skip "Skip Visit" for one-off jobs (only show for recurring jobs)
      if (item.action === 'skip-visit' && !isRecurring) return;

      const div = document.createElement('div');
      div.className = 'menu-item';
      if (item.danger) div.classList.add('menu-danger');

      // Disable Add Photo for now (greyed out, non-interactive)
      if (item.action === 'add-photo') {
        div.classList.add('menu-disabled');
        div.setAttribute('aria-disabled', 'true');
      }

      // Treat Change Frequency as reschedule (reuse schedule modal)
      const action = item.action === 'change-freq' ? 'schedule-visit' : item.action;

      div.textContent = item.text;
      div.dataset.action = action;
      section.appendChild(div);
    });
    menu.appendChild(section);
  }
}
// Escape HTML to prevent XSS in logs
function escapeHtml(unsafe) {
  return unsafe
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}
function formatTimestamp(ts) {
  return new Date(ts).toLocaleString('en-NZ', {
    dateStyle: 'medium',
    timeStyle: 'short'
  });
}
function showModal(contentHTML) {
  const overlay = document.getElementById('modalOverlay');
  const content = document.getElementById('modalContent');
  content.innerHTML = contentHTML;
  overlay.classList.add('active');
}
function closeModal() {
  document.getElementById('modalOverlay').classList.remove('active');
}
function showJobDetailsModal(job, jobId) {
  showModal(`
    <div style="max-width:700px; width:90%; max-height:90vh; overflow-y:auto; padding:24px;">
      <h2 class="modal-title">Job Details ‚Ä¢ ${escapeHtml(job.address || 'No address')}</h2>
      <!-- Client Information -->
      <div class="detail-section">
        <div class="section-header" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'block' ? 'none' : 'block';">
          <h3>Client Information</h3>
          <span class="toggle-icon">‚ñº</span>
        </div>
        <div class="section-content" style="display:none;">
          <p><strong>Name:</strong> ${escapeHtml(job.client?.firstName || '')} ${escapeHtml(job.client?.lastName || '')}</p>
          <p><strong>Email:</strong> ${escapeHtml(job.client?.email || '‚Äî')}</p>
          <p><strong>Phone:</strong> ${escapeHtml(job.client?.phone || '‚Äî')}</p>
        </div>
      </div>
      <!-- Financials -->
      <div class="detail-section">
        <div class="section-header" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'block' ? 'none' : 'block';">
          <h3>Financials</h3>
          <span class="toggle-icon">‚ñº</span>
        </div>
        <div class="section-content" style="display:none;">
          <h4>Quotes (${job.quotes?.length || 0})</h4>
          ${job.quotes?.length > 0 ? job.quotes.map(q => `
            <div style="margin:12px 0; padding:12px; background:#f8f9fc; border-radius:6px; display:flex; justify-content:space-between; align-items:center;">
              <div>
                <strong>${escapeHtml(q.number || 'Quote')}</strong> ‚Äì $${q.total?.toFixed(2) || '‚Äî'} (${q.date || '‚Äî'})
              </div>
              <a href="quote.html?quote=${q.id}" target="_blank" style="background:#7c3aed; color:white; padding:6px 12px; border-radius:6px; text-decoration:none; font-size:0.9rem;">
                View
              </a>
            </div>
          `).join('') : '<p style="color:#6b7280;">No quotes yet</p>'}
          <h4 style="margin-top:24px;">Invoices (${job.invoices?.length || 0})</h4>
          ${job.invoices?.length > 0 ? job.invoices.map(i => `
            <div style="margin:12px 0; padding:12px; background:#f8f9fc; border-radius:6px; display:flex; justify-content:space-between; align-items:center;">
              <div>
                <strong>Invoice #${escapeHtml(i.number || '‚Äî')}</strong> ‚Äì $${i.total?.toFixed(2) || '‚Äî'} (${i.date || '‚Äî'})
              </div>
              <a href="invoice.html?inv=${i.id}" target="_blank" style="background:#10b981; color:white; padding:6px 12px; border-radius:6px; text-decoration:none; font-size:0.9rem;">
                View
              </a>
            </div>
          `).join('') : '<p style="color:#6b7280;">No invoices yet</p>'}
        </div>
      </div>
      <!-- Activity Log -->
      <div class="detail-section">
        <div class="section-header" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'block' ? 'none' : 'block';">
          <h3>Activity Log (${job.activityLog?.length || 0})</h3>
          <span class="toggle-icon">‚ñº</span>
        </div>
        <div class="section-content activity-log" style="display:none;">
          ${job.activityLog?.length > 0 ? job.activityLog.slice().reverse().map(log => `
            <div style="margin:12px 0; padding-bottom:12px; border-bottom:1px solid #eee;">
              <strong>${formatTimestamp(log.timestamp)}</strong>
              <p style="margin:4px 0 0;">${escapeHtml(log.action)}</p>
            </div>
          `).join('') : '<p>No activity logged yet.</p>'}
        </div>
      </div>
      <!-- Manual Status Update -->
      <div style="margin:32px 0;">
        <label style="display:block; margin-bottom:8px; font-weight:600;">Update job status (Manual)</label>
        <select id="manualStatus" class="modal-select">
          <option value="created">Created / Lead</option>
          <option value="quoted">Quote Created</option>
          <option value="quoteSent">Quote Sent</option>
          <option value="won">Job Won</option>
          <option value="progress">In Progress</option>
          <option value="completed">Completed</option>
          <option value="invoiced">Invoiced</option>
          <option value="paid">Paid</option>
        </select>
        <button id="applyManualStatus" class="btn-modal btn-primary-modal" style="margin-top:12px; width:100%;">Apply Status</button>
      </div>
      <!-- Delete Job -->
      <div style="margin-top:32px; text-align:center;">
        <button id="deleteJobBtn" class="btn-modal" style="background:#dc2626; color:white; padding:12px 24px; border:none; border-radius:8px; cursor:pointer;">
          Delete Job
        </button>
      </div>
      <div class="modal-buttons" style="margin-top:40px; justify-content:center;">
        <button class="btn-modal btn-cancel" onclick="closeModal()">Close</button>
      </div>
    </div>
  `);
  const modal = document.getElementById('modalContent');
  // Manual status update ‚Äî sends to backend and reloads all jobs
  modal.querySelector('#applyManualStatus').onclick = async () => {
    const newStatus = modal.querySelector('#manualStatus').value;
    if (!newStatus) return showToast('Select a status');
    
    const card = document.querySelector(`[data-job-id="${jobId}"]`);
    if (!card) return showToast('Card not found');
    
    closeModal();
    await updateJobAndReload(jobId, {
      status: newStatus,
      nextAction: `(Manual) Job set to ${newStatus.charAt(0).toUpperCase() + newStatus.slice(1)}`,
      updatedAt: new Date().toISOString()
    }, card);
  };
  // Delete job ‚Äî uses passed jobId
  modal.querySelector('#deleteJobBtn').onclick = async () => {
    if (!confirm("Delete this job permanently?")) return;
    try {
      const token = await auth.currentUser.getIdToken();
      const res = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
        method: 'DELETE',
        headers: { 'Authorization': `Bearer ${token}` }
      });
      if (!res.ok) throw new Error("Delete failed");
      closeModal();
      loadAndRenderJobs();
      showToast('Job deleted');
    } catch (err) {
      showToast('Failed to delete job: ' + err.message, 'error');
    }
  };
}
function advanceStage(card) {
  const current = card.dataset.stage;
  const idx = STAGES.findIndex(s => s.id === current);
  const nextIdx = (idx + 1) % STAGES.length;
  card.dataset.stage = STAGES[nextIdx].id;
  card.style.opacity = '0.65';
  card.style.transform = 'scale(0.98)';
  setTimeout(() => {
    updateCard(card);
    card.style.opacity = '1';
    card.style.transform = 'scale(1)';
  }, 220);
}
function getPrimaryActionText(stage) {
  const map = {
    quoted: "Send Quote",
    quoteSent: "Schedule Service",
    won: "Start Job",
    progress: "Complete Job",
    completed: "Create Invoice",
    invoiced: "Mark Paid",
    paid: "Schedule Next Visit"
  };
  return map[stage] || "Next Step";
}

// ‚îÄ‚îÄ Calendar navigation state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let displayedMonth = new Date().getMonth();
let displayedYear = new Date().getFullYear();

// ‚îÄ‚îÄ Function to render calendar with job counts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderCalendar(jobs, monthOffset = 0) {
  const calendarGrid = document.getElementById('calendarGrid');
  if (!calendarGrid) return;

  // Calculate month/year to display (with optional offset for navigation)
  const today = new Date();
  let year = displayedYear + Math.floor((displayedMonth + monthOffset) / 12);
  let month = (displayedMonth + monthOffset) % 12;
  
  // Handle negative months
  if (month < 0) {
    month += 12;
    year -= 1;
  }
  
  // Update state
  displayedMonth = month;
  displayedYear = year;
  
  // First day of month and number of days
  const firstDay = new Date(year, month, 1).getDay();
  const daysInMonth = new Date(year, month + 1, 0).getDate();
  
  // Count ONLY on-site jobs due on each day (admin tasks don't add to count)
  const onSitePhases = ['won', 'progress'];
  const jobsByDay = {};
  const jobsScheduledByDay = {}; // All jobs scheduled for each day (regardless of status)
  const jobsWithServiceDateByDay = {}; // Jobs that have a nextServiceDate on each day (for completion checking)
  
  jobs.forEach(job => {
    // Count on-site jobs AND recurring admin jobs (including paid, to show future occurrences)
    const adminPhases = ['created', 'lead', 'quoted', 'quoteSent', 'invoiced', 'paid'];
    const isOnSiteJob = onSitePhases.includes(job.status);
    const isRecurringAdminJob = adminPhases.includes(job.status) && job.isRecurring;
    
    if (!isOnSiteJob && !isRecurringAdminJob) return;
    
    const datesToAdd = [];
    
    // For jobs with nextServiceDate, use that
    if (job.nextServiceDate) {
      // If recurring, generate all occurrences in this month
      if (job.isRecurring && job.recurrence) {
        const startDate = new Date(job.nextServiceDate);
        startDate.setHours(0, 0, 0, 0); // Normalize to local midnight
        let currentDate = new Date(startDate);
        const monthStart = new Date(year, month, 1);
        const monthEnd = new Date(year, month + 1, 0);
        monthEnd.setHours(23, 59, 59, 999); // End of day for proper comparison
        
        // Determine interval in days
        let intervalDays = 0;
        if (job.recurrence.toLowerCase() === 'weekly') {
          intervalDays = 7;
        } else if (job.recurrence.toLowerCase() === 'fortnightly') {
          intervalDays = 14;
        } else if (job.recurrence.toLowerCase() === 'monthly') {
          intervalDays = -1; // Special flag for monthly
        }
        
        // Generate recurring dates
        if (intervalDays > 0) {
          // Weekly or Fortnightly
          while (currentDate <= monthEnd) {
            if (currentDate >= monthStart && currentDate.getFullYear() === year && currentDate.getMonth() === month) {
              datesToAdd.push(new Date(currentDate));
            }
            currentDate.setDate(currentDate.getDate() + intervalDays);
          }
        } else if (intervalDays === -1) {
          // Monthly: add same day of each month
          currentDate = new Date(startDate);
          while (currentDate <= monthEnd) {
            if (currentDate >= monthStart && currentDate.getFullYear() === year && currentDate.getMonth() === month) {
              datesToAdd.push(new Date(currentDate));
            }
            currentDate.setMonth(currentDate.getMonth() + 1);
          }
        }
      } else {
        // Non-recurring: just add the single date
        datesToAdd.push(new Date(job.nextServiceDate));
      }
    }
    
    // Add all dates to jobsByDay count
    datesToAdd.forEach(jobDate => {
      if (jobDate.getFullYear() === year && jobDate.getMonth() === month) {
        const day = jobDate.getDate();
        jobsByDay[day] = (jobsByDay[day] || 0) + 1;
        
        // Track scheduled jobs (for completion check)
        if (!jobsScheduledByDay[day]) jobsScheduledByDay[day] = [];
        jobsScheduledByDay[day].push(job);
        
        // Track jobs with nextServiceDate (for showing checkmark when completed)
        if (!jobsWithServiceDateByDay[day]) jobsWithServiceDateByDay[day] = [];
        jobsWithServiceDateByDay[day].push(job);
      }
    });
  });
  
  // Update month display
  const monthDisplay = document.getElementById('calendarMonth');
  if (monthDisplay) {
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                        'July', 'August', 'September', 'October', 'November', 'December'];
    monthDisplay.textContent = `${monthNames[month]} ${year}`;
  }
  
  // Build calendar grid
  calendarGrid.innerHTML = '';
  
  // Headers
  const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  days.forEach(day => {
    const header = document.createElement('div');
    header.className = 'calendar-day header';
    header.textContent = day;
    calendarGrid.appendChild(header);
  });
  
  // Empty cells before first day
  for (let i = 0; i < firstDay; i++) {
    const emptyCell = document.createElement('div');
    emptyCell.className = 'calendar-day';
    calendarGrid.appendChild(emptyCell);
  }
  
  // Days of month
  for (let day = 1; day <= daysInMonth; day++) {
    const dayCell = document.createElement('div');
    dayCell.className = 'calendar-day';
    
    // Check if date is in the past
    const cellDate = new Date(year, month, day);
    cellDate.setHours(0, 0, 0, 0);
    const todayCompare = new Date();
    todayCompare.setHours(0, 0, 0, 0);
    
    if (cellDate < todayCompare) {
      dayCell.classList.add('past');
    }
    
    // Mark today
    if (day === today.getDate()) {
      dayCell.classList.add('today');
    }
    
    const dayNumber = document.createElement('div');
    dayNumber.className = 'calendar-day-number';
    dayNumber.textContent = day;
    dayCell.appendChild(dayNumber);
    
    if (jobsByDay[day] && jobsByDay[day] > 0) {
      const counter = document.createElement('div');
      counter.className = 'calendar-counter';
      counter.textContent = jobsByDay[day];
      dayCell.appendChild(counter);
    } else if (jobsWithServiceDateByDay[day] && jobsWithServiceDateByDay[day].length > 0) {
      // Jobs were scheduled but no longer in on-site/admin count
      // Check if all jobs with a nextServiceDate for this day are completed
      const allCompleted = jobsWithServiceDateByDay[day].every(job => job.status === 'completed');
      if (allCompleted) {
        const counter = document.createElement('div');
        counter.className = 'calendar-counter';
        counter.textContent = '‚úì';
        counter.style.color = '#16a34a';
        counter.style.fontWeight = 'bold';
        dayCell.appendChild(counter);
      }
    }
    
    // Add click handler to show jobs for that day (only for future dates)
    const clickDate = new Date(year, month, day);
    if (cellDate >= todayCompare) {
      dayCell.addEventListener('click', () => {
        renderJobsForDate(clickDate, jobs);
        // Update calendar highlighting
        document.querySelectorAll('.calendar-day.today').forEach(d => {
          if (d.classList.contains('header')) return;
          d.classList.remove('today');
        });
        dayCell.classList.add('today');
      });
    }
    
    calendarGrid.appendChild(dayCell);
  }
}

// ‚îÄ‚îÄ Function to render jobs for a specific date ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderJobsForDate(selectedDate, jobs) {
  const todayHeading = document.querySelector('h2');
  if (!todayHeading) return;
  
  // Update heading with selected date
  const dateStr = selectedDate.toLocaleDateString('en-NZ', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
  todayHeading.textContent = dateStr;
  
  // Filter and render jobs for this date
  renderTodayJobs(jobs, selectedDate);
}

// ‚îÄ‚îÄ Function to render today's jobs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderTodayJobs(jobs, selectedDate = null) {
  const todayContainer = document.querySelector('.today-previews');
  if (!todayContainer) return;
  
  // Use selected date or today
  const targetDate = selectedDate || new Date();
  targetDate.setHours(0, 0, 0, 0);
  
  // Stages that should show in "Today" section
  const actionStages = ['lead', 'created', 'quoted', 'won', 'progress', 'invoiced', 'paid', 'completed'];
  
  // Helper to get admin task's initial date (when it first becomes visible)
  const getAdminTaskInitialDate = (job) => {
    // Only these phases roll over daily - terminal states (paid, completed, invoiced) don't appear as rolling admin tasks
    const rollingAdminPhases = ['created', 'lead', 'quoted', 'quoteSent'];
    if (!rollingAdminPhases.includes(job.status)) return null;
    
    if ((job.status === 'lead' || job.status === 'created') && job.createdAt) {
      // Show 1 day after creation
      const date = new Date(job.createdAt);
      date.setDate(date.getDate() + 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
    
    if (job.status === 'quoteSent' && job.activityLog && job.activityLog.length > 0) {
      const quoteSentAction = job.activityLog.find(log => 
        log.action && log.action.toLowerCase().includes('quote sent')
      );
      if (quoteSentAction && quoteSentAction.timestamp) {
        // Show 1 day after quote sent
        const date = new Date(quoteSentAction.timestamp);
        date.setDate(date.getDate() + 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    }
    
    if (job.status === 'quoted' && job.createdAt) {
      // For quoted, use creation date
      const date = new Date(job.createdAt);
      date.setHours(0, 0, 0, 0);
      return date;
    }
    
    return null;
  };
  
  // Filter jobs that have actions due on target date
  const todayJobs = jobs.filter(job => {
    const rollingAdminPhases = ['created', 'lead', 'quoted', 'quoteSent'];
    const onSitePhases = ['won', 'progress'];
    const isAdminTask = rollingAdminPhases.includes(job.status);
    const isOnSiteTask = onSitePhases.includes(job.status);
    
    // If checking a specific date, check all the ways a job could appear on that day
    if (selectedDate) {
      // 1. Check if job is ON-SITE (won/progress) with nextServiceDate on this day
      if (isOnSiteTask && job.nextServiceDate) {
        const actionDate = new Date(job.nextServiceDate);
        actionDate.setHours(0, 0, 0, 0);
        if (actionDate.getTime() === targetDate.getTime()) return true;
        
        // Check recurring occurrences
        if (job.isRecurring && job.recurrence) {
          const startDate = new Date(job.nextServiceDate);
          startDate.setHours(0, 0, 0, 0);
          
          let intervalDays = 0;
          if (job.recurrence.toLowerCase() === 'weekly') {
            intervalDays = 7;
          } else if (job.recurrence.toLowerCase() === 'fortnightly') {
            intervalDays = 14;
          } else if (job.recurrence.toLowerCase() === 'monthly') {
            intervalDays = -1; // Special flag for monthly
          }
          
          if (intervalDays > 0) {
            // Weekly or Fortnightly
            const daysDiff = Math.floor((targetDate.getTime() - startDate.getTime()) / (24 * 60 * 60 * 1000));
            if (daysDiff >= 0 && daysDiff % intervalDays === 0) return true;
          } else if (intervalDays === -1) {
            // Monthly: check if same day of month
            if (targetDate.getDate() === startDate.getDate() && targetDate >= startDate) return true;
          }
        }
      }
      
      // 2. Admin tasks roll over: show if initial date <= targetDate and still in admin phase
      if (isAdminTask) {
        // Check if recurring admin job is due on this date
        if (job.isRecurring && job.recurrence && job.nextServiceDate) {
          const startDate = new Date(job.nextServiceDate);
          startDate.setHours(0, 0, 0, 0);
          
          let intervalDays = 0;
          if (job.recurrence.toLowerCase() === 'weekly') {
            intervalDays = 7;
          } else if (job.recurrence.toLowerCase() === 'fortnightly') {
            intervalDays = 14;
          } else if (job.recurrence.toLowerCase() === 'monthly') {
            intervalDays = -1; // Special flag for monthly
          }
          
          if (intervalDays > 0) {
            // Weekly or Fortnightly
            const daysDiff = Math.floor((targetDate.getTime() - startDate.getTime()) / (24 * 60 * 60 * 1000));
            if (daysDiff >= 0 && daysDiff % intervalDays === 0) return true;
          } else if (intervalDays === -1) {
            // Monthly: check if same day of month
            if (targetDate.getDate() === startDate.getDate() && targetDate >= startDate) return true;
          }
        }
        
        const initialDate = getAdminTaskInitialDate(job);
        if (initialDate && initialDate.getTime() <= targetDate.getTime()) {
          return true;
        }
      }
      
      // 3. Check if it's a paid recurring job due for service on this date (shows as "pendingService")
      if (job.status === 'paid' && job.isRecurring && job.nextServiceDate) {
        const startDate = new Date(job.nextServiceDate);
        startDate.setHours(0, 0, 0, 0);
        
        let intervalDays = 0;
        if (job.recurrence.toLowerCase() === 'weekly') {
          intervalDays = 7;
        } else if (job.recurrence.toLowerCase() === 'fortnightly') {
          intervalDays = 14;
        } else if (job.recurrence.toLowerCase() === 'monthly') {
          intervalDays = -1; // Special flag for monthly
        }
        
        if (intervalDays > 0) {
          // Weekly or Fortnightly
          const daysDiff = Math.floor((targetDate.getTime() - startDate.getTime()) / (24 * 60 * 60 * 1000));
          if (daysDiff >= 0 && daysDiff % intervalDays === 0) return true;
        } else if (intervalDays === -1) {
          // Monthly: check if same day of month
          if (targetDate.getDate() === startDate.getDate() && targetDate >= startDate) return true;
        }
      }
      
      return false;
    }
    
    // Default behavior (for today): show new/quoted jobs, or any job with service date today
    // For created and quoteSent, always show in admin (even on the day created/sent)
    if (job.status === 'created' || job.status === 'quoteSent') return true;
    
    // For lead, only show if NOT created today (don't show on creation date)
    if (job.status === 'lead' && job.createdAt) {
      const createdDate = new Date(job.createdAt);
      createdDate.setHours(0, 0, 0, 0);
      if (createdDate.getTime() < targetDate.getTime()) return true;
    }
    
    // Quoted always shows
    if (job.status === 'quoted') return true;
    
    // Jobs that only show if they have a nextServiceDate today (won, progress, completed)
    if (job.nextServiceDate) {
      const actionDate = new Date(job.nextServiceDate);
      actionDate.setHours(0, 0, 0, 0);
      if (actionDate.getTime() === targetDate.getTime()) return true;
    }
    
    // Terminal states (invoiced, completed) appear in admin every day
    if (['invoiced', 'completed'].includes(job.status)) return true;
    
    return false;
  });
  
  if (todayJobs.length === 0) {
    todayContainer.innerHTML = '<p style="text-align:center; color:#6b7280; padding:20px;">No actions due on this date</p>';
    return;
  }
  
  // Separate jobs into On-Site and Admin categories
  const onSitePhases = ['won', 'progress'];
  const rollingAdminPhases = ['created', 'lead', 'quoted', 'quoteSent'];
  const terminalAdminPhases = ['invoiced', 'completed'];
  
  // Add displayStatus for paid recurring jobs due on target date (shows as pendingService)
  todayJobs.forEach(job => {
    if (job.status === 'paid' && job.isRecurring && job.nextServiceDate && selectedDate) {
      const startDate = new Date(job.nextServiceDate);
      startDate.setHours(0, 0, 0, 0);
      
      let intervalDays = 0;
      if (job.recurrence.toLowerCase() === 'weekly') {
        intervalDays = 7;
      } else if (job.recurrence.toLowerCase() === 'fortnightly') {
        intervalDays = 14;
      } else if (job.recurrence.toLowerCase() === 'monthly') {
        intervalDays = -1;
      }
      
      let isDueOnDate = false;
      if (intervalDays > 0) {
        const daysDiff = Math.floor((targetDate.getTime() - startDate.getTime()) / (24 * 60 * 60 * 1000));
        isDueOnDate = daysDiff >= 0 && daysDiff % intervalDays === 0;
      } else if (intervalDays === -1) {
        isDueOnDate = targetDate.getDate() === startDate.getDate() && targetDate >= startDate;
      }
      
      if (isDueOnDate) {
        job.displayStatus = 'pendingService';
        // Also set on original jobs array so expanded card can access it
        const origJob = jobs.find(j => j.id === job.id);
        if (origJob) origJob.displayStatus = 'pendingService';
      }
    }
  });
  
  const onSiteJobs = todayJobs.filter(job => {
    const actualStatus = job.displayStatus || job.status;
    return onSitePhases.includes(actualStatus) || actualStatus === 'pendingService';
  });
  const adminJobs = todayJobs.filter(job => rollingAdminPhases.includes(job.status) || terminalAdminPhases.includes(job.status));
  
  todayContainer.innerHTML = '';
  
  // Helper function to render mini card HTML
  const renderMiniCard = (job) => {
    const displayStatusId = job.displayStatus || job.status;
    const statusInfo = STAGES.find(s => s.id === displayStatusId)
                    || STAGES.find(s => s.id === displayStatusId?.toLowerCase())
                    || STAGES[0];
    
    const actionDate = new Date(job.nextServiceDate);
    const timeString = actionDate.toLocaleTimeString('en-NZ', {
      hour: '2-digit',
      minute: '2-digit'
    });
    
    let actionLabel = job.nextAction || `Next: ${statusInfo.primary}`;
    
    const latestQuote = job.quotes && job.quotes.length > 0
      ? job.quotes.reduce((a, b) => new Date(a.date || a.createdAt) > new Date(b.date || b.createdAt) ? a : b)
      : null;
    const quoteTotal = latestQuote ? `$${latestQuote.total.toFixed(2)}` : 'TBD';
    
    const addrParts = (job.address || 'No address').split(',').map(s => s.trim()).filter(Boolean);
    const addrLine1 = addrParts[0] || '';
    const addrLine2 = addrParts.slice(1).join(', ');
    
    const latestActivityLog = job.activityLog && job.activityLog.length > 0 
      ? job.activityLog[job.activityLog.length - 1]
      : null;
    const activityTimestamp = latestActivityLog 
      ? new Date(latestActivityLog.timestamp).toLocaleTimeString('en-NZ', { hour: '2-digit', minute: '2-digit' })
      : timeString;
    const activityText = latestActivityLog 
      ? `${escapeHtml(latestActivityLog.action)} ‚Ä¢ ${activityTimestamp}`
      : `${actionLabel} ‚Ä¢ ${timeString}`;
    
    return `
      <div class="mini-card" data-job-id="${job.id}" style="position:relative;">
        <div class="mini-left">
          <div class="mini-address-line">${escapeHtml(addrLine1)}</div>
          ${addrLine2 ? `<div class="mini-suburb">${escapeHtml(addrLine2)}</div>` : ''}
          <div class="mini-activity">${activityText}</div>
        </div>
        <div class="mini-right">
          <div class="mini-status ${statusInfo.color}">${statusInfo.label}</div>
          <div class="mini-value">${quoteTotal}</div>
        </div>
      </div>
    `;
  };
  
  // Render On-Site section (non-collapsible container)
  // Check if all on-site jobs are complete
  const allOnSiteComplete = onSiteJobs.length > 0 && onSiteJobs.every(job => job.status === 'completed');
  
  if (allOnSiteComplete) {
    // Show completion message
    const completionHTML = `
      <div class="jobs-section" style="background: #dcfce7; border-radius: 8px; padding: 16px; margin: 12px 0; text-align: center;">
        <h3 style="color: #16a34a; margin: 0; font-size: 1.1rem;">‚úÖ Jobs Complete</h3>
      </div>
    `;
    todayContainer.insertAdjacentHTML('beforeend', completionHTML);
  } else if (onSiteJobs.length > 0) {
    // Show on-site jobs in non-collapsible container
    const onSiteHTML = `
      <div class="jobs-section">
        <h3>On-Site <span class="jobs-section-badge">${onSiteJobs.length}</span></h3>
        <div class="jobs-section-content">
          ${onSiteJobs.map(job => renderMiniCard(job)).join('')}
          <button id="route-apple-maps-btn-today" style="padding: 10px 16px;background: var(--accent);color: white;border: none;border-radius: 8px;font-weight: 600;cursor: pointer;font-size: 0.9rem;transition: background 0.2s, transform 0.15s;display: flex;margin: 10px;/* justify-content: flex-end; */align-items: center;/* flex-direction: row; *//* justify-content: flex-start; */float: right;">
            üó∫Ô∏è Route in Apple Maps
          </button>
        </div>
      </div>
    `;
    todayContainer.insertAdjacentHTML('beforeend', onSiteHTML);
  }
  
  // Render Admin section
  if (adminJobs.length > 0) {
    const adminHTML = `
      <div class="jobs-section">
        <details>
          <summary>
            <h3>Admin <span class="jobs-section-badge">${adminJobs.length}</span></h3>
          </summary>
          <div class="jobs-section-content">
            ${adminJobs.map(job => renderMiniCard(job)).join('')}
          </div>
        </details>
      </div>
    `;
    todayContainer.insertAdjacentHTML('beforeend', adminHTML);
  }
  
  // Attach click handlers to today's mini cards
  todayContainer.querySelectorAll('.mini-card').forEach(card => {
    card.addEventListener('click', (e) => {
      // Don't expand if clicking on details modal
      e.stopPropagation();
      
      const jobId = card.getAttribute('data-job-id');
      const job = jobs.find(j => j.id === jobId);
      if (!job) return;
      
      const cardIndex = Array.from(card.parentElement.children).indexOf(card);
      const scrollY = window.scrollY;
      const cardRect = card.getBoundingClientRect();
      const timestamp = new Date().toLocaleTimeString('en-NZ', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
      
      console.log(`[${timestamp}] [CARD CLICKED] Job: ${job.client?.firstName || 'Unknown'} | Job ID: ${jobId} | Card Index: ${cardIndex}`);
      
      // Close any other expanded mini-card with full animation
      let collapsePromise = Promise.resolve();
      const expandedCards = document.querySelectorAll('.mini-card.expanded');
      console.log(`[${timestamp}] [Found ${expandedCards.length} expanded cards]`);
      
      expandedCards.forEach(expandedCard => {
        if (expandedCard !== card) {
          console.log(`[${timestamp}] [CALLING COLLAPSE]`);
          collapsePromise = collapseExpandedMiniCard(expandedCard, false); // false = animate, returns promise
        }
      });
      
      // Toggle expansion of current card
      if (card.classList.contains('expanded')) {
        collapseExpandedMiniCard(card);
      } else {
        // Wait for collapse to complete, then expand new card
        console.log(`[${timestamp}] [SETTING UP PROMISE CHAIN]`);
        collapsePromise.then(() => {
          const expandTimestamp = new Date().toLocaleTimeString('en-NZ', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
          console.log(`[${expandTimestamp}] [COLLAPSE COMPLETE - EXPANDING NEW CARD]`);
          expandMiniCard(card, job, jobId, jobs);
        });
      }
    });
  });
  
  // Close expanded cards when clicking elsewhere on the page
  document.addEventListener('click', (e) => {
    const expandedCard = document.querySelector('.mini-card.expanded');
    if (expandedCard && !e.target.closest('.mini-card') && !e.target.closest('.job-card-expanded')) {
      collapseExpandedMiniCard(expandedCard);
    }
  }, { capture: true });
}

function expandMiniCard(card, job, jobId, jobs) {
  const timestamp = new Date().toLocaleTimeString('en-NZ', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
  console.log(`[${timestamp}] [EXPAND STARTED] Job: ${job.client?.firstName || 'Unknown'} | Job ID: ${jobId}`);
  
  card.classList.add('expanded');
  
  // Create full job card content
  let clientName = job.client?.firstName || "Unknown";
  if (job.client?.lastName) {
    clientName += ` ${job.client.lastName.charAt(0).toUpperCase()}.`;
  }
  
  // Apply same mapping logic as loadAndRenderJobs
  const displayStatusId = job.displayStatus || job.status;
  const statusInfo = STAGES.find(s => s.id === displayStatusId)
                  || STAGES.find(s => s.id === displayStatusId?.toLowerCase())
                  || STAGES.find(s => s.id === 'quoted') // Default to 'quoted' for new jobs
                  || STAGES[0];
  
  let recurringBadge = "";
  if (job.isRecurring && job.recurrence) {
    recurringBadge = `<span style="font-size:0.82rem; background:#dcfce7; color:#166534; padding:3px 10px; border-radius:12px; margin-left:8px;">
      ${job.recurrence.charAt(0).toUpperCase() + job.recurrence.slice(1)}
    </span>`;
  }
  
  // Get latest quote total if available
  const latestQuoteExpanded = job.quotes && job.quotes.length > 0
    ? job.quotes.reduce((a, b) => new Date(a.date || a.createdAt) > new Date(b.date || b.createdAt) ? a : b)
    : null;
  const quoteTotalExpanded = latestQuoteExpanded ? `$${latestQuoteExpanded.total.toFixed(2)}` : '';
  const quoteTotalDisplay = quoteTotalExpanded ? `<span style="font-weight: 600; color: var(--accent);"> ‚Ä¢ ${quoteTotalExpanded}</span>` : '';
  
  const expandedHTML = `
    <div class="job-card job-card-expanded" 
         data-stage="${statusInfo.id || 'created'}"
         data-job-id="${job.id || 'MISSING-ID'}"
         data-is-recurring="${job.isRecurring ? 'true' : 'false'}"
         style="margin-bottom: 32px; animation: slideDown 0.3s ease;">
      <div class="overflow">‚ãØ</div>
      <div class="menu"></div>
      <div class="job-address">
        ${job.address || 'No address'}${recurringBadge}
      </div>
      <div class="job-client">
        ${clientName} ‚Ä¢ ${job.client?.phone || "No phone"}${quoteTotalDisplay}
        ${job.nextServiceDate ? `
          <div class="next-service">
            Next ${job.recurrence ?
              (job.recurrence.charAt(0).toUpperCase() + job.recurrence.slice(1)) + ' Service' :
              'Service'
            } on ${new Date(job.nextServiceDate).toLocaleDateString('en-NZ', {
              day: 'numeric',
              month: 'short',
              year: 'numeric'
            })}
          </div>
        ` : ''}
      </div>
      <div class="meta">
        <span class="status-badge ${statusInfo.color}">${statusInfo.label}</span>
        <span class="last-activity" data-job-id="${jobId}" style="cursor:pointer; font-style:normal; color:#4b5563; font-weight:500;">
          Last activity: ${job.nextAction || "‚Äî"} ${job.activityLog && job.activityLog.length > 0 ? `<span style="color:var(--accent); font-size:0.8rem;">(${job.activityLog.length} logs)</span>` : ''}
        </span>
      </div>
      <div class="activity-expanded" data-job-id="${jobId}">
        ${job.activityLog && job.activityLog.length > 0 ? job.activityLog.slice().reverse().map(log => `
          <div class="activity-item">
            <div class="activity-timestamp">${formatTimestamp(log.timestamp)}</div>
            <div class="activity-action">${escapeHtml(log.action)}</div>
          </div>
        `).join('') : '<div style="padding:10px; color:#9ca3af;">No activity logged yet.</div>'}
      </div>
      <div class="progress-bar">
        <div class="progress-fill"></div>
      </div>
      <button class="primary-action">${statusInfo.primary}</button>
      <div class="notes-preview" data-job-id="${jobId}">
        <b>NOTES:</b> ${job.jobNotes ? job.jobNotes.substring(0, 120) + (job.jobNotes.length > 120 ? "..." : "") : "No notes added yet"}
      </div>
      <div class="notes-expanded" data-job-id="${jobId}">
        <textarea class="notes-textarea" placeholder="Add job notes...">${job.jobNotes || ''}</textarea>
        <div class="notes-actions">
          <button class="btn-save-notes">Save Notes</button>
          <button class="btn-cancel-notes">Cancel</button>
        </div>
      </div>
    </div>
  `;
  
  // Insert expanded card after mini-card and hide mini-card
  card.style.display = 'none';
  card.insertAdjacentHTML('afterend', expandedHTML);
  
  // Get the newly created expanded card and attach all event listeners
  const expandedCard = card.nextElementSibling;
  attachSingleCardEventListeners(expandedCard, jobs);
  
  // Force layout recalculation by reading offsetHeight
  void expandedCard.offsetHeight;
  
  // Measure after paint to ensure layout has settled
  requestAnimationFrame(() => {
    const cardRect = expandedCard.getBoundingClientRect();
    const cardTop = cardRect.top + window.scrollY;
    const currentScrollY = window.scrollY;
    const targetScroll = cardTop - 80;
    
    const scrollTimestamp = new Date().toLocaleTimeString('en-NZ', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
    console.log(`[${scrollTimestamp}] [SCROLL DETAILS] Card Height: ${cardRect.height} | Current Scroll Y: ${currentScrollY} | Card Top (absolute): ${cardTop} | Card Top (viewport): ${cardRect.top} | Target Scroll: ${targetScroll}`);
    
    // Scroll so the card's top is visible with 80px padding above
    window.scrollTo({
      top: targetScroll,
      behavior: 'smooth'
    });
  });
  
  // Close expanded card when clicking outside
  setTimeout(() => {
    document.addEventListener('click', closeExpandedOnClickOutside);
  }, 0);
}

function collapseExpandedMiniCard(card, instant = false) {
  const expandedCard = card.nextElementSibling;
  if (expandedCard && expandedCard.classList.contains('job-card-expanded')) {
    return new Promise((resolve) => {
      if (instant) {
        // Instantly collapse without animation when new card clicked
        expandedCard.remove();
        card.style.display = '';
        card.classList.remove('expanded');
        const timestamp = new Date().toLocaleTimeString('en-NZ', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
        console.log(`[${timestamp}] [CARD INSTANTLY COLLAPSED]`);
        resolve();
      } else {
        // Normal collapse with animation
        const timestamp = new Date().toLocaleTimeString('en-NZ', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
        console.log(`[${timestamp}] [STARTING COLLAPSE ANIMATION]`);
        expandedCard.style.animation = 'slideUp 0.3s ease';
        setTimeout(() => {
          expandedCard.remove();
          card.style.display = '';
          card.classList.remove('expanded');
          const completeTimestamp = new Date().toLocaleTimeString('en-NZ', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
          console.log(`[${completeTimestamp}] [COLLAPSE ANIMATION COMPLETE - CARD REMOVED]`);
          resolve();
        }, 300);
      }
    });
  }
  return Promise.resolve();
}

function closeExpandedOnClickOutside(e) {
  const expandedCard = document.querySelector('.mini-card.expanded');
  if (expandedCard && 
      !e.target.closest('.mini-card.expanded') && 
      !e.target.closest('.job-card-expanded') &&
      e.target.closest('.today-previews')) {
    // Only close if clicking within today-previews area
    if (!e.target.closest('.mini-card:not(.expanded)')) {
      collapseExpandedMiniCard(expandedCard);
      document.removeEventListener('click', closeExpandedOnClickOutside);
    }
  }
}

function attachSingleCardEventListeners(card, jobs) {
  // 1. Update card visuals (progress, badge, button text, menu items)
  updateCard(card);
  
  // 2. Primary action button (full implementation matching attachCardEventListeners)
  const primaryBtn = card.querySelector('.primary-action');
  if (primaryBtn) {
    primaryBtn.addEventListener('click', async () => {
      const stage = card.getAttribute('data-stage') || 'unknown';
      const jobId = card.getAttribute('data-job-id') || '';
      const quoteIdFromCard = card.getAttribute('data-quote-id') || '';
      const isRecurring = card.dataset.isRecurring === 'true';
      
      console.log('[Primary button clicked on expanded card]', {
        stage,
        jobId,
        quoteIdFromCard,
        hasJobId: !!jobId,
        hasQuoteId: !!quoteIdFromCard && quoteIdFromCard.trim() !== '',
        isRecurring
      });
      
      // ‚îÄ‚îÄ Handle paid stage ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (stage === 'paid') {
        if (isRecurring) {
          showScheduleModal(card);
          return;
        } else {
          return;
        }
      }
      
      // ‚îÄ‚îÄ Handle pendingService stage (Start Service for recurring jobs) ‚îÄ‚îÄ‚îÄ
      if (stage === 'pendingService') {
        showModal(`
          <h2 class="modal-title">Start Service</h2>
          <p style="margin-bottom:20px; color:#4b5563;">
            Ready to start this service?
          </p>
          <div class="modal-buttons">
            <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
            <button class="btn-modal btn-primary-modal confirm-start-service">Yes ‚Äì Start Service</button>
          </div>
        `);
        const modal = document.getElementById('modalContent');
        modal.querySelector('.confirm-start-service').addEventListener('click', async () => {
          try {
            const user = auth.currentUser;
            if (!user) throw new Error("Not signed in");
            const token = await user.getIdToken();
            if (!jobId) throw new Error("No job ID on card");
            const patchBody = {
              status: 'progress',
              nextAction: 'Service started on site',
              startedAt: new Date().toISOString(),
              updatedAt: new Date().toISOString()
            };
            const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
              method: 'PATCH',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
              },
              body: JSON.stringify(patchBody)
            });
            if (!patchRes.ok) throw new Error(`PATCH failed: ${patchRes.status}`);
            closeModal();
            showToast('‚úì Service started', 'success');
            await loadAndRenderJobs(jobs);
          } catch (err) {
            console.error('[Start service failed]', err);
            showToast(`Failed to start service:\n${err.message}`, 'error');
          }
        });
        return;
      }
      
      // ‚îÄ‚îÄ Handle lead stage (Create Quote) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (stage === 'lead') {
        if (!jobId) {
          showToast('No job ID found');
          return;
        }
        window.location.href = `create_quote.html?jobId=${jobId}`;
        return;
      }
      
      // ‚îÄ‚îÄ Handle quoted stage ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (stage === 'quoted') {
        showModal(`
          <h2 class="modal-title">Send Quote</h2>
          <p style="margin-bottom:20px; color:#4b5563;">Choose how to send the quote to the client:</p>
          <div class="send-options">
            <button class="btn-modal btn-primary-modal btn-send send-email">Email</button>
            <button class="btn-modal btn-primary-modal btn-send send-sms">SMS</button>
            <button class="btn-modal btn-primary-modal btn-send send-clipboard">Copy to Clipboard</button>
          </div>
          <div class="modal-buttons" style="margin-top:24px;">
            <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
          </div>
        `);
        const modalContent = document.getElementById('modalContent');
        modalContent.querySelectorAll('.send-email, .send-sms, .send-clipboard').forEach(btn => {
          btn.addEventListener('click', async () => {
            const isEmail = btn.classList.contains('send-email');
            const isSMS = btn.classList.contains('send-sms');
            const isClipboard = btn.classList.contains('send-clipboard');
            
            btn.disabled = true;
            btn.textContent = isEmail ? "Sending..." : (isSMS ? "Sending..." : "Copying...");
            let finalQuoteId = quoteIdFromCard;
            
            try {
              if (!finalQuoteId || finalQuoteId.trim() === '') {
                const user = auth.currentUser;
                if (!user) throw new Error("Not signed in");
                const token = await user.getIdToken();
                if (!jobId) throw new Error("No job ID");
                const jobRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
                  headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!jobRes.ok) throw new Error(`Job fetch failed: ${jobRes.status}`);
                const jobData = await jobRes.json();
                const latestQ = jobData.quotes?.length > 0
                  ? jobData.quotes.reduce((a, b) => new Date(a.date) > new Date(b.date) ? a : b)
                  : null;
                finalQuoteId = latestQ?.id;
                if (!finalQuoteId) throw new Error("No quote found");
              }
              
              const user = auth.currentUser;
              if (!user) throw new Error("Not signed in");
              const token = await user.getIdToken();
              
              // Update backend status to quoteSent for all methods
              const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
                method: 'PATCH',
                headers: {
                  'Authorization': `Bearer ${token}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  status: 'quoteSent',
                  nextAction: `Quote sent via ${isEmail ? 'email' : isSMS ? 'SMS' : 'clipboard'}`,
                  updatedAt: new Date().toISOString()
                })
              });
              
              if (!patchRes.ok) {
                const errData = await patchRes.json().catch(() => ({}));
                throw new Error(errData.error || `Update failed (${patchRes.status})`);
              }
              
              // If email, also call the send-email endpoint
              if (isEmail) {
                const sendRes = await fetch(`${WORKER_URL}/api/quotes/${finalQuoteId}/send-email`, {
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                  }
                });
                if (!sendRes.ok) {
                  let errMsg = await sendRes.text().catch(() => `HTTP ${sendRes.status}`);
                  throw new Error(errMsg);
                }
                showToast('Quote email sent successfully!', 'success');
              } else if (isClipboard) {
                showToast('Quote link copied to clipboard!');
              } else if (isSMS) {
                // Show SMS modal to send via client's SMS app
                try {
                  let jobData = null;
                  try {
                    const jobRes2 = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, { headers: { 'Authorization': `Bearer ${token}` } });
                    if (jobRes2.ok) jobData = await jobRes2.json();
                  } catch (e) { /* ignore */ }

                  const clientName = (jobData?.client?.firstName || jobData?.client?.name || 'Customer') + (jobData?.client?.lastName ? ` ${jobData.client.lastName}` : '');
                  const clientPhone = jobData?.client?.phone || jobData?.client?.mobile || jobData?.client?.phoneNumber;
                  if (!clientPhone) throw new Error('Client phone number not found');

                  const publicLink = `${window.location.origin}/roof/quote.html?quote=${finalQuoteId}`;

                  let company = { companyName: 'Company', phone: '' };
                  try {
                    const profRes = await fetch(`${WORKER_URL}/api/user/profile`, { headers: { 'Authorization': `Bearer ${token}` } });
                    if (profRes.ok) {
                      const pj = await profRes.json();
                      company.companyName = pj.profile?.companyName || company.companyName;
                      company.phone = pj.profile?.phone || '';
                    }
                  } catch (e) {}

                  const message = window.buildMessageFromTemplate('quote_sent', { clientName, quoteUrl: publicLink, vendorName: company.companyName, vendorNumber: company.phone });
                  window.showSmsModal(clientName, clientPhone, message, { jobId, template: 'quote_sent', vars: { clientName, quoteUrl: publicLink, vendorName: company.companyName, vendorNumber: company.phone } });
                } catch (e) {
                  console.error('SMS prepare failed', e);
                  showToast('Failed to prepare SMS: ' + (e.message || e), 'error');
                }
              }
              
              closeModal();
              await loadAndRenderJobs();
              showToast('Quote sent successfully!', 'success');
            } catch (err) {
              console.error('[Send quote failed]', err);
              showToast(`Failed to send quote:\n${err.message}`, 'error');
            } finally {
              btn.disabled = false;
              btn.textContent = isEmail ? "Email" : (isSMS ? "SMS" : "Copy to Clipboard");
            }
          });
        });
      }
      
      // ‚îÄ‚îÄ Handle quoteSent stage ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      else if (stage === 'quoteSent') {
        showScheduleModal(card);
      }
      
      // ‚îÄ‚îÄ Handle won stage (Start Job) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      else if (stage === 'won') {
        showModal(`
          <h2 class="modal-title">Start Job</h2>
          <p style="margin-bottom:20px; color:#4b5563;">
            Are you sure you want to start this job on site?
          </p>
          <div class="modal-buttons">
            <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
            <button class="btn-modal btn-primary-modal confirm-start-job">Yes ‚Äì Start Job</button>
          </div>
        `);
        const modal = document.getElementById('modalContent');
        modal.querySelector('.confirm-start-job').addEventListener('click', async () => {
          try {
            const user = auth.currentUser;
            if (!user) throw new Error("Not signed in");
            const token = await user.getIdToken();
            const jobId = card.getAttribute('data-job-id');
            if (!jobId) throw new Error("No job ID on card");
            const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
              method: 'PATCH',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                status: 'progress',
                nextAction: 'Service started on site',
                startedAt: new Date().toISOString()
              })
            });
            if (!patchRes.ok) {
              const errData = await patchRes.json().catch(() => ({}));
              throw new Error(errData.error || `Update failed (${patchRes.status})`);
            }
            closeModal();
            await loadAndRenderJobs();
            showToast('Service started on site!', 'success');
          } catch (err) {
            console.error("Start job failed:", err);
            showToast('Failed to start job:\n' + err.message, 'error');
          }
        });
      }
      
      // ‚îÄ‚îÄ Handle progress stage (Complete Job) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      else if (stage === 'progress') {
        showModal(`
          <h2 class="modal-title">Complete Job</h2>
          <p style="margin-bottom:20px; color:#4b5563;">
            Mark this job as completed?<br>
            You can create an invoice afterwards.
          </p>
          <div class="modal-buttons">
            <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
            <button class="btn-modal btn-primary-modal confirm-complete-job">Yes ‚Äì Complete</button>
          </div>
        `);
        const modal = document.getElementById('modalContent');
        modal.querySelector('.confirm-complete-job').addEventListener('click', async () => {
          try {
            const user = auth.currentUser;
            if (!user) throw new Error("Not signed in");
            const token = await user.getIdToken();
            const jobId = card.getAttribute('data-job-id');
            if (!jobId) throw new Error("No job ID on card");
            const patchBody = {
              status: 'completed',
              nextAction: 'Job completed',
              completedAt: new Date().toISOString(),
              updatedAt: new Date().toISOString()
            };
            const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
              method: 'PATCH',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(patchBody)
            });
            if (!patchRes.ok) {
              const errData = await patchRes.json().catch(() => ({}));
              throw new Error(errData.error || `Update failed (${patchRes.status})`);
            }
            closeModal();
            await loadAndRenderJobs();
            showToast('Job marked as completed!', 'success');
          } catch (err) {
            console.error("Complete job failed:", err);
            showToast('Failed to complete job:\n' + err.message, 'error');
          }
        });
      }
      
      // ‚îÄ‚îÄ Handle completed stage (Create Invoice) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      else if (stage === 'completed') {
        showModal(`
          <div id="invoiceStep1">
            <h2 class="modal-title">Create Invoice</h2>
            <p style="margin-bottom:16px; color:#4b5563;">
              Select which quote to base the invoice on:
            </p>
            <label style="display:block; margin-bottom:8px; font-weight:600;">Quote</label>
            <select id="modal-quote-select" class="modal-select">
              <option value="">-- Select a quote --</option>
            </select>
            <div class="modal-buttons" style="margin-top:24px;">
              <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
              <button id="next-to-send" class="btn-modal btn-primary-modal" disabled>Next ‚Üí</button>
            </div>
          </div>
          <div id="invoiceStep2" style="display:none;">
            <h2 class="modal-title">Send Invoice</h2>
            <p style="margin-bottom:20px; color:#4b5563;">
              How would you like to send the invoice to the client?
            </p>
            <div class="send-options">
              <button class="btn-modal btn-primary-modal btn-send send-email">Email</button>
              <button class="btn-modal btn-primary-modal btn-send send-sms">SMS</button>
              <button class="btn-modal btn-primary-modal btn-send send-clipboard">Copy to Clipboard</button>
            </div>
            <div class="modal-buttons" style="margin-top:24px;">
              <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
            </div>
          </div>
        `);
        const modalContent = document.getElementById('modalContent');
        const quoteSelect = modalContent.querySelector('#modal-quote-select');
        const nextBtn = modalContent.querySelector('#next-to-send');
        const jobId = card.getAttribute('data-job-id');
        
        (async () => {
          try {
            const token = await auth.currentUser.getIdToken();
            const res = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            if (!res.ok) throw new Error("Couldn't load job quotes");
            const job = await res.json();
            const quotes = job.quotes || [];
            if (quotes.length === 0) {
              quoteSelect.innerHTML = '<option value="">No quotes found for this job</option>';
              return;
            }
            quotes.forEach(q => {
              const opt = document.createElement('option');
              opt.value = q.id;
              const dateStr = new Date(q.date || q.createdAt || Date.now())
                .toLocaleDateString('en-NZ', { day: 'numeric', month: 'short', year: 'numeric' });
              const amount = (q.totalInclGst || q.total || 0).toFixed(2);
              opt.textContent = `${q.number || 'Quote'} ‚Äì ${dateStr} ‚Äì $${amount}`;
              opt.dataset.quoteId = q.id;
              quoteSelect.appendChild(opt);
            });
            quoteSelect.addEventListener('change', () => {
              nextBtn.disabled = !quoteSelect.value;
            });
          } catch (err) {
            console.error(err);
            quoteSelect.innerHTML = '<option value="">Error loading quotes</option>';
          }
        })();
        
        nextBtn.addEventListener('click', () => {
          document.getElementById('invoiceStep1').style.display = 'none';
          document.getElementById('invoiceStep2').style.display = 'block';
        });
        
        modalContent.querySelectorAll('.send-email, .send-sms, .send-clipboard').forEach(btn => {
          btn.addEventListener('click', async () => {
            const selectedQuoteId = quoteSelect.value;
            if (!selectedQuoteId) return showToast('Please select a quote first');
            try {
              const token = await auth.currentUser.getIdToken();
              const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
                method: 'PATCH',
                headers: {
                  'Authorization': `Bearer ${token}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  status: 'invoiced',
                  nextAction: 'Invoice created',
                  invoicedAt: new Date().toISOString(),
                  updatedAt: new Date().toISOString()
                })
              });
              if (!patchRes.ok) {
                const errData = await patchRes.json().catch(() => ({}));
                throw new Error(errData.error || `Update failed (${patchRes.status})`);
              }
              closeModal();
              window.location.href = `create_invoice.html?jobId=${jobId}&quoteId=${selectedQuoteId}`;
            } catch (err) {
              console.error("Invoice creation flow failed:", err);
              showToast('Failed to update job status:\n' + err.message, 'error');
            }
          });
        });
      }
      
      // ‚îÄ‚îÄ Handle invoiced stage (Mark as Paid) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      else if (stage === 'invoiced') {
        showModal(`
          <h2 class="modal-title">Mark as Paid</h2>
          <p style="margin-bottom:20px; color:#4b5563;">
            Confirm that the full invoice has been paid?<br>
            This will move the job to "Paid" status.
          </p>
          <div class="modal-buttons">
            <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
            <button class="btn-modal btn-primary-modal confirm-mark-paid">Yes ‚Äì Mark as Paid</button>
          </div>
        `);
        const modal = document.getElementById('modalContent');
        modal.querySelector('.confirm-mark-paid').addEventListener('click', async () => {
          try {
            const user = auth.currentUser;
            if (!user) throw new Error("Not signed in");
            const token = await user.getIdToken();
            const jobId = card.getAttribute('data-job-id');
            if (!jobId) throw new Error("No job ID on card");
            const patchBody = {
              status: 'paid',
              nextAction: 'Payment received',
              paidAt: new Date().toISOString(),
              updatedAt: new Date().toISOString()
            };
            const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
              method: 'PATCH',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(patchBody)
            });
            if (!patchRes.ok) {
              const errData = await patchRes.json().catch(() => ({}));
              throw new Error(errData.error || `Update failed (${patchRes.status})`);
            }
            closeModal();
            await loadAndRenderJobs();
            showToast('Job marked as paid!', 'success');
          } catch (err) {
            console.error("Mark as paid failed:", err);
            showToast('Failed to mark job as paid:\n' + err.message, 'error');
          }
        });
      }
    });
  }
  
  // 3. Overflow menu
  const overflow = card.querySelector('.overflow');
  const menu = card.querySelector('.menu');
  if (overflow && menu) {
    overflow.addEventListener('click', e => {
      e.stopPropagation();
      document.querySelectorAll('.menu.show').forEach(m => m.classList.remove('show'));
      menu.classList.toggle('show');
    });
  }

  // 4. Menu item clicks (schedule-visit, view-details, edit-quote, delete-quote)
  card.querySelectorAll('.menu-item').forEach(item => {
    item.addEventListener('click', async () => {
      // Ignore clicks on disabled items
      if (item.classList.contains('menu-disabled')) return;
      const action = item.dataset.action;
      const jobId = card.getAttribute('data-job-id') || '';
      const quoteId = card.getAttribute('data-quote-id') || '';
      const currentMenu = card.querySelector('.menu');
      
      if (action === 'view-details') {
        if (currentMenu) currentMenu.classList.remove('show');
        const jobId = card.getAttribute('data-job-id');
        if (!jobId) {
          showToast('Cannot load details ‚Äî job ID missing');
          return;
        }
        const token = await auth.currentUser.getIdToken();
        fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        })
        .then(res => {
          if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
          return res.json();
        })
        .then(data => {
          const fullJob = data.jobs?.find(j => j.id === jobId) || data;
          showJobDetailsModal(fullJob, jobId);
        })
        .catch(err => {
          console.error("Failed to load job details:", err);
          showToast('Could not load job details: ' + err.message);
        });
      }
      else if (action === 'edit-quote') {
        window.location.href = `create_quote.html?jobId=${jobId}&quote=${quoteId}&edit=true`;
      }
      else if (action === 'delete-quote') {
        if (!confirm("Delete this quote? The job will revert to 'Lead' status.")) return;
        if (!quoteId || quoteId.trim() === '') {
          showToast('Cannot delete ‚Äî no quote is associated with this job card');
          return;
        }
        try {
          const user = auth.currentUser;
          if (!user) throw new Error("Not signed in");
          const token = await user.getIdToken();
          const res = await fetch(`${WORKER_URL}/api/quotes/${quoteId}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${token}` }
          });
          if (!res.ok) {
            const errBody = await res.json().catch(() => ({}));
            throw new Error(errBody.error || `Delete failed (${res.status})`);
          }
          if (currentMenu) currentMenu.classList.remove('show');
          await loadAndRenderJobs();
          showToast('Quote deleted successfully', 'success');
        } catch (err) {
          console.error("Delete quote failed:", err);
          showToast('Failed to delete quote:\n' + err.message, 'error');
        }
      }
      else if (action === 'resend-quote') {
        if (currentMenu) currentMenu.classList.remove('show');
        // Resend Quote uses the same flow as Send Quote
        showModal(`
          <h2 class="modal-title">Resend Quote</h2>
          <p style="margin-bottom:20px; color:#4b5563;">Choose how to resend the quote to the client:</p>
          <div class="send-options">
            <button class="btn-modal btn-primary-modal btn-send send-email">Email</button>
            <button class="btn-modal btn-primary-modal btn-send send-sms">SMS</button>
            <button class="btn-modal btn-primary-modal btn-send send-clipboard">Copy to Clipboard</button>
          </div>
          <div class="modal-buttons" style="margin-top:24px;">
            <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
          </div>
        `);
        const resendModalContent = document.getElementById('modalContent');
        resendModalContent.querySelectorAll('.send-email, .send-sms, .send-clipboard').forEach(btn => {
          btn.addEventListener('click', async () => {
            const isEmail = btn.classList.contains('send-email');
            const isSMS = btn.classList.contains('send-sms');
            const isClipboard = btn.classList.contains('send-clipboard');
            
            btn.disabled = true;
            btn.textContent = isEmail ? "Sending..." : (isSMS ? "Sending..." : "Copying...");
            let finalQuoteId = quoteId;
            
            try {
              if (!finalQuoteId || finalQuoteId.trim() === '') {
                const user = auth.currentUser;
                if (!user) throw new Error("Not signed in");
                const token = await user.getIdToken();
                if (!jobId) throw new Error("No job ID");
                const jobRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
                  headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!jobRes.ok) throw new Error(`Job fetch failed: ${jobRes.status}`);
                const jobData = await jobRes.json();
                const latestQ = jobData.quotes?.length > 0
                  ? jobData.quotes.reduce((a, b) => new Date(a.date) > new Date(b.date) ? a : b)
                  : null;
                finalQuoteId = latestQ?.id;
                if (!finalQuoteId) throw new Error("No quote found");
              }
              
              const user = auth.currentUser;
              if (!user) throw new Error("Not signed in");
              const token = await user.getIdToken();
              
              // If email, call the send-email endpoint
              if (isEmail) {
                const sendRes = await fetch(`${WORKER_URL}/api/quotes/${finalQuoteId}/send-email`, {
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                  }
                });
                if (!sendRes.ok) {
                  let errMsg = await sendRes.text().catch(() => `HTTP ${sendRes.status}`);
                  throw new Error(errMsg);
                }
                showToast('Quote email resent successfully!', 'success');
              } else if (isClipboard) {
                showToast('Quote link copied to clipboard!');
              } else if (isSMS) {
                // Resend via SMS using the quote_sent template
                try {
                  let jobData = null;
                  try {
                    const jobRes2 = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, { headers: { 'Authorization': `Bearer ${token}` } });
                    if (jobRes2.ok) jobData = await jobRes2.json();
                  } catch (e) { /* ignore */ }

                  const clientName = (jobData?.client?.firstName || jobData?.client?.name || 'Customer') + (jobData?.client?.lastName ? ` ${jobData.client.lastName}` : '');
                  const clientPhone = jobData?.client?.phone || jobData?.client?.mobile || jobData?.client?.phoneNumber;
                  if (!clientPhone) throw new Error('Client phone number not found');

                  const publicLink = `${window.location.origin}/roof/quote.html?quote=${finalQuoteId}`;

                  let company = { companyName: 'Company', phone: '' };
                  try {
                    const profRes = await fetch(`${WORKER_URL}/api/user/profile`, { headers: { 'Authorization': `Bearer ${token}` } });
                    if (profRes.ok) {
                      const pj = await profRes.json();
                      company.companyName = pj.profile?.companyName || company.companyName;
                      company.phone = pj.profile?.phone || '';
                    }
                  } catch (e) {}

                  const message = window.buildMessageFromTemplate('quote_sent', { clientName, quoteUrl: publicLink, vendorName: company.companyName, vendorNumber: company.phone });
                  window.showSmsModal(clientName, clientPhone, message, { jobId, template: 'quote_sent', vars: { clientName, quoteUrl: publicLink, vendorName: company.companyName, vendorNumber: company.phone } });
                } catch (e) {
                  console.error('SMS prepare failed', e);
                  showToast('Failed to prepare SMS: ' + (e.message || e), 'error');
                }
              }
              
              closeModal();
            } catch (err) {
              console.error('[Resend quote failed]', err);
              showToast(`Failed to resend quote:\n${err.message}`, 'error');
            } finally {
              btn.disabled = false;
              btn.textContent = isEmail ? "Email" : (isSMS ? "SMS" : "Copy to Clipboard");
            }
          });
        });
      }
      else if (action === 'send-reminder') {
        if (currentMenu) currentMenu.classList.remove('show');

        // If this card is in 'invoiced' stage, show invoice-specific reminder flow
        if (card.dataset.stage === 'invoiced') {
          showModal(`
            <h2 class="modal-title">Send Invoice Reminder</h2>
            <p style="margin-bottom:12px; color:#4b5563;">Select which invoice to send a reminder for:</p>
            <label style="display:block; margin-bottom:8px; font-weight:600;">Invoice</label>
            <select id="modal-invoice-select" class="modal-select"><option value="">Loading...</option></select>
            <p style="margin:16px 0 8px 0; color:#4b5563;">How would you like to send the reminder?</p>
            <div class="send-options">
              <button class="btn-modal btn-primary-modal btn-send send-email">Email</button>
              <button class="btn-modal btn-primary-modal btn-send send-sms">SMS</button>
              <button class="btn-modal btn-primary-modal btn-send send-clipboard">Copy to Clipboard</button>
            </div>
            <div class="modal-buttons" style="margin-top:24px;">
              <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
            </div>
          `);

          const modalContent = document.getElementById('modalContent');
          const invoiceSelect = modalContent.querySelector('#modal-invoice-select');

          (async () => {
            try {
              const token = await auth.currentUser.getIdToken();
              const res = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, { headers: { 'Authorization': `Bearer ${token}` } });
              if (!res.ok) throw new Error('Could not load job invoices');
              const job = await res.json();
              const invoices = job.invoices || [];
              if (invoices.length === 0) {
                invoiceSelect.innerHTML = '<option value="">No invoices for this job</option>';
                return;
              }
              invoiceSelect.innerHTML = '<option value="">-- Select invoice --</option>' + invoices.map(i => `<option value="${i.id}">${i.number || i.id} ‚Ä¢ ${i.date} ‚Ä¢ $${(i.total||0).toFixed(2)}</option>`).join('');
            } catch (e) {
              console.error('Failed to load invoices', e);
              invoiceSelect.innerHTML = '<option value="">Error loading invoices</option>';
            }
          })();

          modalContent.querySelectorAll('.send-email, .send-sms, .send-clipboard').forEach(btn => {
            btn.addEventListener('click', async () => {
              const selectedInvoiceId = invoiceSelect.value;
              if (!selectedInvoiceId) return showToast('Please select an invoice first');
              const isEmail = btn.classList.contains('send-email');
              const isSMS = btn.classList.contains('send-sms');
              const isClipboard = btn.classList.contains('send-clipboard');

              btn.disabled = true;
              btn.textContent = isEmail ? 'Sending...' : (isSMS ? 'Sending...' : 'Copying...');

              try {
                const user = auth.currentUser;
                if (!user) throw new Error('Not signed in');
                const token = await user.getIdToken();

                if (isEmail) {
                  const res = await fetch(`${WORKER_URL}/api/invoices/${selectedInvoiceId}/send-email`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }
                  });
                  if (!res.ok) {
                    const txt = await res.text().catch(() => `HTTP ${res.status}`);
                    throw new Error(txt);
                  }
                  showToast('Invoice reminder email sent successfully!', 'success');
                } else if (isClipboard) {
                  const link = `${window.location.origin}/roof/invoice.html?inv=${selectedInvoiceId}`;
                  try { await navigator.clipboard.writeText(link); showToast('Invoice link copied to clipboard'); } catch { showToast('Failed to copy to clipboard', 'error'); }
                } else if (isSMS) {
                  // Fetch job & invoice to build sms vars
                  const tkn = await auth.currentUser.getIdToken();
                  let jobData = null;
                  try {
                    const jobRes2 = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, { headers: { 'Authorization': `Bearer ${tkn}` } });
                    if (jobRes2.ok) jobData = await jobRes2.json();
                  } catch (e) {}
                  const clientPhone = jobData?.client?.phone || jobData?.client?.mobile || jobData?.client?.phoneNumber;
                  if (!clientPhone) {
                    showToast('Client phone not found');
                  } else {
                    // Find invoice total/date for vars
                    const invoiceObj = (jobData?.invoices || []).find(i => i.id === selectedInvoiceId) || null;
                    const amount = invoiceObj ? `$${Number(invoiceObj.total||0).toFixed(2)}` : '';
                    const publicLink = `${window.location.origin}/roof/invoice.html?inv=${selectedInvoiceId}`;
                    // fetch vendor profile
                    let vendorName = 'Company', vendorNumber = '';
                    try {
                      const profRes = await fetch(`${WORKER_URL}/api/user/profile`, { headers: { 'Authorization': `Bearer ${tkn}` } });
                      if (profRes.ok) { const pj = await profRes.json(); vendorName = pj.profile?.companyName || vendorName; vendorNumber = pj.profile?.phone || vendorNumber; }
                    } catch (e) {}

                    const message = window.buildMessageFromTemplate('invoice_reminder', { clientName: (jobData?.client?.firstName||'Customer'), invoiceUrl: publicLink, dueDate: '', amount, vendorName, vendorNumber });
                    window.showSmsModal(jobData?.client?.firstName || 'Customer', clientPhone, message, { invoiceId: selectedInvoiceId, template: 'invoice_reminder', vars: { clientName: (jobData?.client?.firstName||'Customer'), invoiceUrl: publicLink, amount, vendorName, vendorNumber } });
                  }
                }
                closeModal();
              } catch (err) {
                console.error('Invoice reminder failed', err);
                showToast('Failed to send invoice reminder:\n' + (err.message || err, 'error'));
              } finally {
                btn.disabled = false;
                btn.textContent = isEmail ? 'Email' : (isSMS ? 'SMS' : 'Copy to Clipboard');
              }
            });
          });
          return;
        }

        // Fallback: existing quote reminder flow (unchanged)
        showModal(`
          <h2 class="modal-title">Send Reminder</h2>
          <p style="margin-bottom:20px; color:#4b5563;">Choose how to send the reminder to the client:</p>
          <div class="send-options">
            <button class="btn-modal btn-primary-modal btn-send send-email">Email</button>
            <button class="btn-modal btn-primary-modal btn-send send-sms">SMS</button>
            <button class="btn-modal btn-primary-modal btn-send send-clipboard">Copy to Clipboard</button>
          </div>
          <div class="modal-buttons" style="margin-top:24px;">
            <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
          </div>
        `);
        const reminderModalContent = document.getElementById('modalContent');
        reminderModalContent.querySelectorAll('.send-email, .send-sms, .send-clipboard').forEach(btn => {
          btn.addEventListener('click', async () => {
            const isEmail = btn.classList.contains('send-email');
            const isSMS = btn.classList.contains('send-sms');
            const isClipboard = btn.classList.contains('send-clipboard');
            
            btn.disabled = true;
            btn.textContent = isEmail ? "Sending..." : (isSMS ? "Sending..." : "Copying...");
            
            try {
              const user = auth.currentUser;
              if (!user) throw new Error("Not signed in");
              const token = await user.getIdToken();
              
              if (isEmail) {
                // Email reminder - call backend email reminder endpoint
                const reminderRes = await fetch(`${WORKER_URL}/api/quotes/${quoteId}/send-reminder-email`, {
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                  }
                });
                if (!reminderRes.ok) {
                  let errMsg = await reminderRes.text().catch(() => `HTTP ${reminderRes.status}`);
                  throw new Error(errMsg);
                }
                showToast('Reminder email sent successfully!', 'success');
              } else if (isClipboard) {
                // Copy to clipboard
                const reminderLink = `${window.location.origin}/roof/quote.html?quote=${quoteId}`;
                navigator.clipboard.writeText(reminderLink).then(() => {
                  showToast('Reminder link copied to clipboard!');
                }).catch(() => {
                  showToast('Failed to copy to clipboard', 'error');
                });
              } else if (isSMS) {
                // Send SMS reminder via client's SMS app
                try {
                  // Fetch job data to get client phone/name
                  let jobData = null;
                  try {
                    const jobRes2 = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, { headers: { 'Authorization': `Bearer ${token}` } });
                    if (jobRes2.ok) jobData = await jobRes2.json();
                  } catch (e) { /* ignore */ }
                  
                  const clientName = (jobData?.client?.firstName || jobData?.client?.name || 'Customer') + (jobData?.client?.lastName ? ` ${jobData.client.lastName}` : '');
                  const clientPhone = jobData?.client?.phone || jobData?.client?.mobile || jobData?.client?.phoneNumber;
                  if (!clientPhone) throw new Error('Client phone number not found');

                  const publicLink = `${window.location.origin}/roof/quote.html?quote=${quoteId}`;

                  // Fetch company profile for vendor details
                  let company = { companyName: 'Company', phone: '' };
                  try {
                    const profRes = await fetch(`${WORKER_URL}/api/user/profile`, { headers: { 'Authorization': `Bearer ${token}` } });
                    if (profRes.ok) {
                      const pj = await profRes.json();
                      company.companyName = pj.profile?.companyName || company.companyName;
                      company.phone = pj.profile?.phone || '';
                    }
                  } catch (e) {}

                  const message = window.buildMessageFromTemplate('quote_reminder', { clientName, quoteUrl: publicLink, vendorName: company.companyName, vendorNumber: company.phone });
                  window.showSmsModal(clientName, clientPhone, message, { jobId, template: 'quote_reminder', vars: { clientName, quoteUrl: publicLink, vendorName: company.companyName, vendorNumber: company.phone } });
                } catch (e) {
                  console.error('SMS prepare failed', e);
                  showToast('Failed to prepare SMS: ' + (e.message || e), 'error');
                }
              }
              
              closeModal();
            } catch (err) {
              console.error('[Send reminder failed]', err);
              showToast(`Failed to send reminder:\n${err.message}`, 'error');
            } finally {
              btn.disabled = false;
              btn.textContent = isEmail ? "Email" : (isSMS ? "SMS" : "Copy to Clipboard");
            }
          });
        });
      }
      else if (action === 'schedule-visit') {
        if (currentMenu) currentMenu.classList.remove('show');
        showScheduleModal(card);
      }
      
      if (currentMenu) currentMenu.classList.remove('show');
    });
  });

  // 5. Notes section - click to expand/edit
  const notesPreview = card.querySelector('.notes-preview');
  const notesExpanded = card.querySelector('.notes-expanded');
  const saveNotesBtn = card.querySelector('.btn-save-notes');
  const cancelNotesBtn = card.querySelector('.btn-cancel-notes');
  const notesTextarea = card.querySelector('.notes-textarea');
  const jobId = card.getAttribute('data-job-id');

  if (notesPreview && notesExpanded) {
    notesPreview.addEventListener('click', () => {
      notesExpanded.classList.add('open');
      notesPreview.style.display = 'none';
      notesTextarea?.focus();
    });

    cancelNotesBtn?.addEventListener('click', () => {
      notesExpanded.classList.remove('open');
      notesPreview.style.display = 'block';
    });

    saveNotesBtn?.addEventListener('click', async () => {
      try {
        const notes = notesTextarea?.value || '';
        const user = auth.currentUser;
        if (!user) throw new Error("Not signed in");
        const token = await user.getIdToken();
        
        const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
          method: 'PATCH',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            jobNotes: notes,
            updatedAt: new Date().toISOString()
          })
        });

        if (!patchRes.ok) {
          const errData = await patchRes.json().catch(() => ({}));
          throw new Error(errData.error || `Update failed (${patchRes.status})`);
        }

        // Update the preview text
        const preview = notes ? notes.substring(0, 120) + (notes.length > 120 ? "..." : "") : "No notes added yet";
        notesPreview.innerHTML = `<b>NOTES:</b> ${preview}`;
        
        notesExpanded.classList.remove('open');
        notesPreview.style.display = 'block';
        showToast('Notes saved successfully!', 'success');
        loadAndRenderJobs();
      } catch (err) {
        console.error("Save notes failed:", err);
        showToast('Failed to save notes:\n' + err.message, 'error');
      }
    });
  }

  // 6. Activity log section - click to expand
  const activityButton = card.querySelector('.last-activity');
  const activityExpanded = card.querySelector('.activity-expanded');

  if (activityButton && activityExpanded) {
    activityButton.addEventListener('click', (e) => {
      e.stopPropagation();
      activityExpanded.classList.toggle('open');
    });
  }
}

// ‚îÄ‚îÄ Main render function ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let allJobs = []; // Store all jobs for search functionality

async function loadAndRenderJobs(useMockData = false) {
  const container = document.getElementById("jobs-container");
  if (!container) {
    console.error('‚ùå jobs-container not found!');
    return;
  }
  container.innerHTML = '<p style="text-align:center; color:#6b7280; padding:40px;">Loading jobs...</p>';
  try {
    let jobs;
    if (useMockData) {
      // Load from mock data
      jobs = mockJobsData.jobs || [];
    } else {
      // Load from server (original behavior)
      const user = auth.currentUser;
      if (!user) throw new Error("Not signed in. Please log in first.");
      const token = await user.getIdToken(true);
      console.log('üì° Fetching jobs from API...');
      const res = await fetch(`${WORKER_URL}/api/jobs`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      if (!res.ok) {
        const errText = await res.text().catch(() => "No details");
        throw new Error(`Server error ${res.status} ‚Äì ${errText}`);
      }
      const data = await res.json();
      jobs = data.jobs || [];
      console.log(`‚úì Loaded ${jobs.length} jobs from API`);
    }
    
    // Store all jobs for search functionality
    allJobs = jobs;
    
    // Reset search input
    const searchInput = document.getElementById('jobSearch');
    if (searchInput) {
      searchInput.value = '';
    }
    
    // Reset heading to "Today"
    const headings = document.querySelectorAll('h2');
    if (headings[0]) {
      headings[0].textContent = 'Today';
    }
    
    // Render today's jobs at the top
    renderTodayJobs(jobs);
    
    // Render calendar with job counts
    renderCalendar(jobs, 0);
    
    // Attach month navigation handlers
    const prevBtn = document.getElementById('prevMonthBtn');
    const nextBtn = document.getElementById('nextMonthBtn');
    if (prevBtn) prevBtn.addEventListener('click', () => renderCalendar(jobs, -1));
    if (nextBtn) nextBtn.addEventListener('click', () => renderCalendar(jobs, 1));
    
    if (jobs.length === 0) {
      container.innerHTML = '<p style="text-align:center; color:#6b7280; padding:40px;">No jobs yet.<br>Create your first job!</p>';
      console.log('‚ÑπÔ∏è No jobs to display');
      return;
    }
    container.innerHTML = '';
    console.log(`üé¥ Rendering ${jobs.length} job cards...`);
    jobs.forEach(job => {
      const statusInfo = STAGES.find(s => s.id === job.status)
                      || STAGES.find(s => s.id === job.status?.toLowerCase())
                      || STAGES[0];
      let clientName = job.client?.firstName || "Unknown";
      if (job.client?.lastName) {
        clientName += ` ${job.client.lastName.charAt(0).toUpperCase()}.`;
      }
      
      // Get latest quote total if available
      const latestQuote = job.quotes && job.quotes.length > 0
        ? job.quotes.reduce((a, b) => new Date(a.date || a.createdAt) > new Date(b.date || b.createdAt) ? a : b)
        : null;
      const quoteTotal = latestQuote ? `$${latestQuote.total.toFixed(2)}` : 'TBD';
      
      // Split address into lines by comma
      const addrParts = (job.address || 'No address').split(',').map(s => s.trim()).filter(Boolean);
      const addrLine1 = addrParts[0] || '';
      const addrLine2 = addrParts.slice(1).join(', ');
      
      // Get latest activity log entry
      const latestActivityLog = job.activityLog && job.activityLog.length > 0 
        ? job.activityLog[job.activityLog.length - 1]
        : null;
      const timeString = new Date(job.nextServiceDate).toLocaleTimeString('en-NZ', {
        hour: '2-digit',
        minute: '2-digit'
      });
      const activityTimestamp = latestActivityLog 
        ? new Date(latestActivityLog.timestamp).toLocaleTimeString('en-NZ', { hour: '2-digit', minute: '2-digit' })
        : timeString;
      const actionLabel = job.nextAction || `Next: ${statusInfo.primary}`;
      const activityText = latestActivityLog 
        ? `${escapeHtml(latestActivityLog.action)} ‚Ä¢ ${activityTimestamp}`
        : `${actionLabel} ‚Ä¢ ${timeString}`;
      
      const miniCardHTML = `
        <div class="mini-card" data-job-id="${job.id}" style="position:relative;">
          <div class="mini-left">
            <div class="mini-address-line">${escapeHtml(addrLine1)}</div>
            ${addrLine2 ? `<div class="mini-suburb">${escapeHtml(addrLine2)}</div>` : ''}
            <div class="mini-activity">${activityText}</div>
          </div>
          <div class="mini-right">
            <div class="mini-status ${statusInfo.color}">${statusInfo.label}</div>
            <div class="mini-value">${quoteTotal}</div>
          </div>
        </div>
      `;
      container.insertAdjacentHTML("beforeend", miniCardHTML);
    });
    
    // Attach click handlers to all mini cards (same as today's mini cards)
    container.querySelectorAll('.mini-card').forEach(card => {
      card.addEventListener('click', (e) => {
        e.stopPropagation();
        
        const jobId = card.getAttribute('data-job-id');
        const job = jobs.find(j => j.id === jobId);
        if (!job) return;
        
        const timestamp = new Date().toLocaleTimeString('en-NZ', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
        console.log(`[${timestamp}] [CARD CLICKED] Job: ${job.client?.firstName || 'Unknown'} | Job ID: ${jobId}`);
        
        // Close any other expanded mini-card with full animation
        let collapsePromise = Promise.resolve();
        const expandedCards = document.querySelectorAll('.mini-card.expanded');
        console.log(`[${timestamp}] [Found ${expandedCards.length} expanded cards]`);
        
        expandedCards.forEach(expandedCard => {
          if (expandedCard !== card) {
            console.log(`[${timestamp}] [CALLING COLLAPSE]`);
            collapsePromise = collapseExpandedMiniCard(expandedCard, false); // false = animate, returns promise
          }
        });
        
        // Toggle expansion of current card
        if (card.classList.contains('expanded')) {
          collapseExpandedMiniCard(card);
        } else {
          // Wait for collapse to complete, then expand new card
          console.log(`[${timestamp}] [SETTING UP PROMISE CHAIN]`);
          collapsePromise.then(() => {
            const expandTimestamp = new Date().toLocaleTimeString('en-NZ', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
            console.log(`[${expandTimestamp}] [COLLAPSE COMPLETE - EXPANDING NEW CARD]`);
            expandMiniCard(card, job, jobId, jobs);
          });
        }
      });
    });
    
    setupSearchListener();
  } catch (err) {
    console.error("Failed to load jobs:", err);
    container.innerHTML = `<p style="text-align:center; color:#dc2626; padding:40px; white-space:pre-wrap;">
      Could not load jobs\n\n${err.message}
    </p>`;
  }
}

// ‚îÄ‚îÄ Search functionality ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function setupSearchListener() {
  const searchInput = document.getElementById('jobSearch');
  if (!searchInput) return;
  
  searchInput.addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase().trim();
    const container = document.getElementById("jobs-container");
    
    if (!searchTerm) {
      // Show all jobs if search is empty
      const allMiniCards = container.querySelectorAll('.mini-card:not(.expanded)');
      allMiniCards.forEach(card => {
        card.style.display = '';
      });
      return;
    }
    
    // Filter jobs based on search
    const allMiniCards = container.querySelectorAll('.mini-card:not(.expanded)');
    allMiniCards.forEach(card => {
      const jobId = card.getAttribute('data-job-id');
      const job = allJobs.find(j => j.id === jobId);
      
      if (!job) {
        card.style.display = 'none';
        return;
      }
      
      // Create searchable string from job data (all lowercase)
      const searchableText = JSON.stringify(job).toLowerCase();
      
      // Check if search term matches anything in the job
      const matches = searchableText.includes(searchTerm);
      
      card.style.display = matches ? '' : 'none';
    });
  });
}

function showScheduleModal(card) {
  // Optional: dynamic default date (next week)
  const nextWeek = new Date();
  nextWeek.setDate(nextWeek.getDate() + 7);
  const defaultDate = nextWeek.toISOString().split('T')[0];
  showModal(`
    <h2 class="modal-title">Schedule Service</h2>
    <label style="display:block; margin-bottom:8px; font-weight:600;">Frequency</label>
    <select class="modal-select" id="frequencySelect">
      <option>One-off</option>
      <option>Weekly</option>
      <option selected>Fortnightly</option>
      <option>Monthly</option>
    </select>
    <label style="display:block; margin:16px 0 8px; font-weight:600;">Start Date</label>
    <input type="date" class="modal-input" id="nextDateInput" value="${defaultDate}">
    <div class="modal-buttons">
      <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
      <button class="btn-modal btn-primary-modal confirm-schedule">Confirm Schedule</button>
    </div>
  `);
  const modal = document.getElementById('modalContent');
  modal.querySelector('.confirm-schedule').addEventListener('click', async () => {
    const frequency = modal.querySelector('#frequencySelect').value;
    const nextDate = modal.querySelector('#nextDateInput').value;
    if (!nextDate) {
      showToast('Please select a start date');
      return;
    }
    try {
      const user = auth.currentUser;
      if (!user) throw new Error("Not signed in");
      const token = await user.getIdToken();
      const jobId = card.getAttribute('data-job-id');
      if (!jobId) throw new Error("No job ID on card");
      const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          isRecurring: frequency !== 'One-off',
          recurrence: frequency !== 'One-off' ? frequency.toLowerCase() : null,
          nextServiceDate: nextDate,
          status: 'won', // or 'progress' ‚Äî your choice
          nextAction: `Scheduled: ${frequency} starting ${new Date(nextDate).toLocaleDateString('en-NZ')}`
        })
      });
      if (!patchRes.ok) {
        const errData = await patchRes.json().catch(() => ({}));
        throw new Error(errData.error || `Save failed (${patchRes.status})`);
      }
      
      closeModal();
      await loadAndRenderJobs();
      showToast('Service scheduled successfully!', 'success');
    } catch (err) {
      console.error("Schedule save failed:", err);
      showToast('Failed to save schedule:\n' + err.message, 'error');
    }
  });
}
function attachCardEventListeners() {
  const cards = document.querySelectorAll('.job-card');
  cards.forEach(card => {
    // 1. Update card visuals (progress, badge, button text, menu items)
    updateCard(card);
    // 2. Primary action button ("Send Quote", "Schedule Service", "Start Job", etc.)
    const primaryBtn = card.querySelector('.primary-action');
    if (primaryBtn) {
      primaryBtn.addEventListener('click', async () => {
        const stage = card.getAttribute('data-stage') || 'unknown';
        const jobId = card.getAttribute('data-job-id') || '';
        const quoteIdFromCard = card.getAttribute('data-quote-id') || '';
        const isRecurring = card.dataset.isRecurring === 'true';
        console.log('[Primary button clicked]', {
          stage,
          jobId,
          quoteIdFromCard,
          hasJobId: !!jobId,
          hasQuoteId: !!quoteIdFromCard && quoteIdFromCard.trim() !== '',
          isRecurring
        });
        // ‚îÄ‚îÄ NEW: Handle paid stage ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (stage === 'paid') {
          if (isRecurring) {
            showScheduleModal(card);
            return;
          } else {
            // One-off paid job ‚Äî optional: open details or do nothing
            // For now, do nothing since it's disabled in updateCard
            return;
          }
        }
        // ‚îÄ‚îÄ NEW: Handle pendingService stage (Start Service for recurring jobs) ‚îÄ‚îÄ‚îÄ
        if (stage === 'pendingService') {
          showModal(`
            <h2 class="modal-title">Start Service</h2>
            <p style="margin-bottom:20px; color:#4b5563;">
              Ready to start this service?
            </p>
            <div class="modal-buttons">
              <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
              <button class="btn-modal btn-primary-modal confirm-start-service">Yes ‚Äì Start Service</button>
            </div>
          `);
          const modal = document.getElementById('modalContent');
          modal.querySelector('.confirm-start-service').addEventListener('click', async () => {
            try {
              const user = auth.currentUser;
              if (!user) throw new Error("Not signed in");
              const token = await user.getIdToken();
              if (!jobId) throw new Error("No job ID on card");
              const patchBody = {
                status: 'progress',
                nextAction: 'Service started on site',
                startedAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
              };
              const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
                method: 'PATCH',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify(patchBody)
              });
              if (!patchRes.ok) throw new Error(`PATCH failed: ${patchRes.status}`);
              closeModal();
              showToast('‚úì Service started', 'success');
              await loadAndRenderJobs();
            } catch (err) {
              console.error('[Start service failed]', err);
              showToast(`Failed to start service:\n${err.message}`, 'error');
            }
          });
          return;
        }
        // ‚îÄ‚îÄ NEW: Handle lead stage (Create Quote) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (stage === 'lead') {
          const jobId = card.getAttribute('data-job-id');
          if (!jobId) {
            showToast('No job ID found');
            return;
          }
          window.location.href = `create_quote.html?jobId=${jobId}`;
          return;
        }
        // ‚îÄ‚îÄ Existing stage handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (stage === 'quoted') {
          // Send Quote modal (your existing flow)
          showModal(`
            <h2 class="modal-title">Send Quote</h2>
            <p style="margin-bottom:20px; color:#4b5563;">Choose how to send the quote to the client:</p>
            <div class="send-options">
              <button class="btn-modal btn-primary-modal btn-send send-email">Email</button>
              <button class="btn-modal btn-primary-modal btn-send send-sms">SMS</button>
              <button class="btn-modal btn-primary-modal btn-send send-clipboard">Copy to Clipboard</button>
            </div>
            <div class="modal-buttons" style="margin-top:24px;">
              <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
            </div>
          `);
          const modalContent = document.getElementById('modalContent');
          modalContent.querySelectorAll('.send-email, .send-sms, .send-clipboard').forEach(btn => {
            btn.addEventListener('click', async () => {
              const isEmail = btn.classList.contains('send-email');
              const isSMS = btn.classList.contains('send-sms');
              const isClipboard = btn.classList.contains('send-clipboard');
              
              btn.disabled = true;
              btn.textContent = isEmail ? "Sending..." : (isSMS ? "Sending..." : "Copying...");
              let finalQuoteId = quoteIdFromCard;
              
              try {
                if (!finalQuoteId || finalQuoteId.trim() === '') {
                  console.warn('[Fallback] No quoteId ‚Üí fetching job');
                  const user = auth.currentUser;
                  if (!user) throw new Error("Not signed in");
                  const token = await user.getIdToken();
                  if (!jobId) throw new Error("No job ID");
                  const jobRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                  });
                  if (!jobRes.ok) throw new Error(`Job fetch failed: ${jobRes.status}`);
                  const jobData = await jobRes.json();
                  const latestQ = jobData.quotes?.length > 0
                    ? jobData.quotes.reduce((a, b) => new Date(a.date) > new Date(b.date) ? a : b)
                    : null;
                  finalQuoteId = latestQ?.id;
                  if (!finalQuoteId) throw new Error("No quote found");
                }
                
                const user = auth.currentUser;
                if (!user) throw new Error("Not signed in");
                const token = await user.getIdToken();
                
                // Update backend status to quoteSent for all methods
                const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
                  method: 'PATCH',
                  headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    status: 'quoteSent',
                    nextAction: `Quote sent via ${isEmail ? 'email' : isSMS ? 'SMS' : 'clipboard'}`,
                    updatedAt: new Date().toISOString()
                  })
                });
                
                if (!patchRes.ok) {
                  const errData = await patchRes.json().catch(() => ({}));
                  throw new Error(errData.error || `Update failed (${patchRes.status})`);
                }
                
                // If email, also call the send-email endpoint
                if (isEmail) {
                  const sendRes = await fetch(`${WORKER_URL}/api/quotes/${finalQuoteId}/send-email`, {
                    method: 'POST',
                    headers: {
                      'Authorization': `Bearer ${token}`,
                      'Content-Type': 'application/json'
                    }
                  });
                  if (!sendRes.ok) {
                    let errMsg = await sendRes.text().catch(() => `HTTP ${sendRes.status}`);
                    throw new Error(errMsg);
                  }
                  showToast('Quote email sent successfully!', 'success');
                } else if (isClipboard) {
                  showToast('Quote link copied to clipboard!');
                } else if (isSMS) {
                  // Show SMS modal to send via client's SMS app
                  try {
                    // Ensure we have job data to get client phone/name
                    let jobData = null;
                    try {
                      const jobRes2 = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, { headers: { 'Authorization': `Bearer ${token}` } });
                      if (jobRes2.ok) jobData = await jobRes2.json();
                    } catch (e) { /* ignore */ }

                    const clientName = (jobData?.client?.firstName || jobData?.client?.name || 'Customer') + (jobData?.client?.lastName ? ` ${jobData.client.lastName}` : '');
                    const clientPhone = jobData?.client?.phone || jobData?.client?.mobile || jobData?.client?.phoneNumber;
                    if (!clientPhone) throw new Error('Client phone number not found');

                    const publicLink = `${window.location.origin}/roof/quote.html?quote=${finalQuoteId}`;

                    // Fetch company profile for vendor details (optional)
                    let company = { companyName: 'Company', phone: '' };
                    try {
                      const profRes = await fetch(`${WORKER_URL}/api/user/profile`, { headers: { 'Authorization': `Bearer ${token}` } });
                      if (profRes.ok) {
                        const pj = await profRes.json();
                        company.companyName = pj.profile?.companyName || company.companyName;
                        company.phone = pj.profile?.phone || '';
                      }
                    } catch (e) {}

                    const message = window.buildMessageFromTemplate('quote_sent', { clientName, quoteUrl: publicLink, vendorName: company.companyName, vendorNumber: company.phone });
                    window.showSmsModal(clientName, clientPhone, message, { jobId, template: 'quote_sent', vars: { clientName, quoteUrl: publicLink, vendorName: company.companyName, vendorNumber: company.phone } });
                  } catch (e) {
                    console.error('SMS prepare failed', e);
                    showToast('Failed to prepare SMS: ' + (e.message || e), 'error');
                  }
                }
                
                closeModal();
                card.dataset.stage = 'quoteSent';
                updateCard(card);
                loadAndRenderJobs(); // refresh to sync backend
              } catch (err) {
                console.error('[Send quote failed]', err);
                showToast(`Failed to send quote:\n${err.message}`, 'error');
              } finally {
                btn.disabled = false;
                btn.textContent = isEmail ? "Email" : (isSMS ? "SMS" : "Copy to Clipboard");
              }
            });
          });
        }
        else if (stage === 'quoteSent') {
          showScheduleModal(card);
        }
        else if (stage === 'won') {
          // New: Start Job confirmation modal
          showModal(`
            <h2 class="modal-title">Start Job</h2>
            <p style="margin-bottom:20px; color:#4b5563;">
              Are you sure you want to start this job on site?
            </p>
            <div class="modal-buttons">
              <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
              <button class="btn-modal btn-primary-modal confirm-start-job">Yes ‚Äì Start Job</button>
            </div>
          `);
          const modal = document.getElementById('modalContent');
          modal.querySelector('.confirm-start-job').addEventListener('click', async () => {
            try {
              const user = auth.currentUser;
              if (!user) throw new Error("Not signed in");
              const token = await user.getIdToken();
              const jobId = card.getAttribute('data-job-id');
              if (!jobId) throw new Error("No job ID on card");
              const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
                method: 'PATCH',
                headers: {
                  'Authorization': `Bearer ${token}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  status: 'progress',
                  nextAction: 'Service started on site', // ‚Üê changed wording
                  startedAt: new Date().toISOString()
                })
              });
              if (!patchRes.ok) {
                const errData = await patchRes.json().catch(() => ({}));
                throw new Error(errData.error || `Update failed (${patchRes.status})`);
              }
              closeModal();
              await loadAndRenderJobs();
              showToast('Service started on site!', 'success');
            } catch (err) {
              console.error("Start job failed:", err);
              showToast('Failed to start job:\n' + err.message, 'error');
            }
          });
        }
        else if (stage === 'progress') {
          // ‚îÄ‚îÄ Complete Job ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          showModal(`
            <h2 class="modal-title">Complete Job</h2>
            <p style="margin-bottom:20px; color:#4b5563;">
              Mark this job as completed?<br>
              You can create an invoice afterwards.
            </p>
            <div class="modal-buttons">
              <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
              <button class="btn-modal btn-primary-modal confirm-complete-job">Yes ‚Äì Complete</button>
            </div>
          `);
          const modal = document.getElementById('modalContent');
          modal.querySelector('.confirm-complete-job').addEventListener('click', async () => {
            try {
              const user = auth.currentUser;
              if (!user) throw new Error("Not signed in");
              const token = await user.getIdToken();
              const jobId = card.getAttribute('data-job-id');
              if (!jobId) throw new Error("No job ID on card");
              // Prepare patch payload
              const patchBody = {
                status: 'completed',
                nextAction: 'Job completed',
                completedAt: new Date().toISOString(), // optional ‚Äì nice to have
                updatedAt: new Date().toISOString()
              };
              const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
                method: 'PATCH',
                headers: {
                  'Authorization': `Bearer ${token}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(patchBody)
              });
              if (!patchRes.ok) {
                const errData = await patchRes.json().catch(() => ({}));
                throw new Error(errData.error || `Update failed (${patchRes.status})`);
              }
              closeModal();
              await loadAndRenderJobs();
              showToast('Job marked as completed!', 'success');
            } catch (err) {
              console.error("Complete job failed:", err);
              showToast('Failed to complete job:\n' + err.message, 'error');
            }
          });
        }
        else if (stage === 'completed') {
          // ‚îÄ‚îÄ Create Invoice from Completed Job ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          showModal(`
            <div id="invoiceStep1">
              <h2 class="modal-title">Create Invoice</h2>
              <p style="margin-bottom:16px; color:#4b5563;">
                Select which quote to base the invoice on:
              </p>
              <label style="display:block; margin-bottom:8px; font-weight:600;">Quote</label>
              <select id="modal-quote-select" class="modal-select">
                <option value="">-- Select a quote --</option>
              </select>
              <div class="modal-buttons" style="margin-top:24px;">
                <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
                <button id="next-to-send" class="btn-modal btn-primary-modal" disabled>Next ‚Üí</button>
              </div>
            </div>
            <div id="invoiceStep2" style="display:none;">
              <h2 class="modal-title">Send Invoice</h2>
              <p style="margin-bottom:20px; color:#4b5563;">
                How would you like to send the invoice to the client?
              </p>
              <div class="send-options">
                <button class="btn-modal btn-primary-modal btn-send send-email">Email</button>
                <button class="btn-modal btn-primary-modal btn-send send-sms">SMS</button>
                <button class="btn-modal btn-primary-modal btn-send send-clipboard">Copy to Clipboard</button>
              </div>
              <div class="modal-buttons" style="margin-top:24px;">
                <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
              </div>
            </div>
          `);
          const modalContent = document.getElementById('modalContent');
          const quoteSelect = modalContent.querySelector('#modal-quote-select');
          const nextBtn = modalContent.querySelector('#next-to-send');
          const jobId = card.getAttribute('data-job-id');
          // ‚îÄ‚îÄ Populate quotes dropdown ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          (async () => {
            try {
              const token = await auth.currentUser.getIdToken();
              const res = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
                headers: { 'Authorization': `Bearer ${token}` }
              });
              if (!res.ok) throw new Error("Couldn't load job quotes");
              const job = await res.json();
              const quotes = job.quotes || [];
              if (quotes.length === 0) {
                quoteSelect.innerHTML = '<option value="">No quotes found for this job</option>';
                return;
              }
              quotes.forEach(q => {
                const opt = document.createElement('option');
                opt.value = q.id;
                const dateStr = new Date(q.date || q.createdAt || Date.now())
                  .toLocaleDateString('en-NZ', { day: 'numeric', month: 'short', year: 'numeric' });
                const amount = (q.totalInclGst || q.total || 0).toFixed(2);
                opt.textContent = `${q.number || 'Quote'} ‚Äì ${dateStr} ‚Äì $${amount}`;
                opt.dataset.quoteId = q.id;
                quoteSelect.appendChild(opt);
              });
              // Enable next button once a quote is selected
              quoteSelect.addEventListener('change', () => {
                nextBtn.disabled = !quoteSelect.value;
              });
            } catch (err) {
              console.error(err);
              quoteSelect.innerHTML = '<option value="">Error loading quotes</option>';
            }
          })();
          // Next ‚Üí button (switch to step 2)
          nextBtn.addEventListener('click', () => {
            document.getElementById('invoiceStep1').style.display = 'none';
            document.getElementById('invoiceStep2').style.display = 'block';
          });
          // Send buttons ‚Üí do backend update + redirect
          modalContent.querySelectorAll('.send-email, .send-sms, .send-clipboard').forEach(btn => {
            btn.addEventListener('click', async () => {
              const selectedQuoteId = quoteSelect.value;
              if (!selectedQuoteId) return showToast('Please select a quote first');
              try {
                // Save user's desired send method so create_invoice.html can act after invoice is created
                const method = btn.classList.contains('send-email') ? 'email' : (btn.classList.contains('send-sms') ? 'sms' : 'clipboard');
                try {
                  localStorage.setItem('pendingInvoiceSend', JSON.stringify({ method, jobId, quoteId: selectedQuoteId, ts: Date.now() }));
                } catch (e) {
                  console.warn('Could not write pendingInvoiceSend to localStorage', e);
                }
                const token = await auth.currentUser.getIdToken();
                // Update job status to 'invoiced'
                const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
                  method: 'PATCH',
                  headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    status: 'invoiced',
                    nextAction: 'Invoice created',
                    invoicedAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                  })
                });
                if (!patchRes.ok) {
                  const errData = await patchRes.json().catch(() => ({}));
                  throw new Error(errData.error || `Update failed (${patchRes.status})`);
                }
                closeModal();
                // Redirect to invoice creation page with jobId & selected quoteId
                window.location.href = `create_invoice.html?jobId=${jobId}&quoteId=${selectedQuoteId}`;
              } catch (err) {
                console.error("Invoice creation flow failed:", err);
                showToast('Failed to update job status:\n' + err.message, 'error');
              }
            });
          });
        }
        else if (stage === 'invoiced') {
          // ‚îÄ‚îÄ Mark as Paid ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          showModal(`
            <h2 class="modal-title">Mark as Paid</h2>
            <p style="margin-bottom:20px; color:#4b5563;">
              Confirm that the full invoice has been paid?<br>
              This will move the job to "Paid" status.
            </p>
            <div class="modal-buttons">
              <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
              <button class="btn-modal btn-primary-modal confirm-mark-paid">Yes ‚Äì Mark as Paid</button>
            </div>
          `);
          const modal = document.getElementById('modalContent');
          modal.querySelector('.confirm-mark-paid').addEventListener('click', async () => {
            try {
              const user = auth.currentUser;
              if (!user) throw new Error("Not signed in");
              const token = await user.getIdToken();
              const jobId = card.getAttribute('data-job-id');
              if (!jobId) throw new Error("No job ID on card");
              const patchBody = {
                status: 'paid',
                nextAction: 'Payment received',
                paidAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
              };
              const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
                method: 'PATCH',
                headers: {
                  'Authorization': `Bearer ${token}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(patchBody)
              });
              if (!patchRes.ok) {
                const errData = await patchRes.json().catch(() => ({}));
                throw new Error(errData.error || `Update failed (${patchRes.status})`);
              }
              closeModal();
              await loadAndRenderJobs();
              showToast('Job marked as paid!', 'success');
            } catch (err) {
              console.error("Mark as paid failed:", err);
              showToast('Failed to mark job as paid:\n' + err.message, 'error');
            }
          });
        }
        else {
          advanceStage(card);
        }
      });
    }
    // 3. Overflow ‚ãØ menu toggle
    const overflow = card.querySelector('.overflow');
    const menu = card.querySelector('.menu');
    if (overflow && menu) {
      overflow.addEventListener('click', e => {
        e.stopPropagation();
        document.querySelectorAll('.menu.show').forEach(m => m.classList.remove('show'));
        menu.classList.toggle('show');
      });
    }
    // 4. Menu item clicks (including delete-quote + schedule-visit)
    card.querySelectorAll('.menu-item').forEach(item => {
      item.addEventListener('click', async () => {
        const action = item.dataset.action;
        const jobId = card.getAttribute('data-job-id') || '';
        const quoteId = card.getAttribute('data-quote-id') || '';
        const currentMenu = card.querySelector('.menu');
        if (action === 'view-details') {
          if (currentMenu) currentMenu.classList.remove('show');
          const jobId = card.getAttribute('data-job-id');
          if (!jobId) {
            showToast('Cannot load details ‚Äî job ID missing');
            return;
          }
          // Fetch fresh job data (recommended for full details)
          const token = await auth.currentUser.getIdToken();
          fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
            headers: { 'Authorization': `Bearer ${token}` }
          })
          .then(res => {
            if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
            return res.json();
          })
          .then(data => {
            const fullJob = data.jobs?.find(j => j.id === jobId) || data;
            showJobDetailsModal(fullJob, jobId); // ‚Üê pass jobId (string)
          })
          .catch(err => {
            console.error("Failed to load job details:", err);
            showToast('Could not load job details: ' + err.message);
          });
        }
        else if (action === 'edit-quote') {
          window.location.href = `create_quote.html?jobId=${jobId}&quote=${quoteId}&edit=true`;
        }
        else if (action === 'delete-quote') {
          if (!confirm("Delete this quote? The job will revert to 'Lead' status.")) return;
          if (!quoteId || quoteId.trim() === '') {
            showToast('Cannot delete ‚Äî no quote is associated with this job card');
            return;
          }
          try {
            const user = auth.currentUser;
            if (!user) throw new Error("Not signed in");
            const token = await user.getIdToken();
            const res = await fetch(`${WORKER_URL}/api/quotes/${quoteId}`, {
              method: 'DELETE',
              headers: { 'Authorization': `Bearer ${token}` }
            });
            if (!res.ok) {
              const errBody = await res.json().catch(() => ({}));
              throw new Error(errBody.error || `Delete failed (${res.status})`);
            }
            if (currentMenu) currentMenu.classList.remove('show');
            await loadAndRenderJobs();
            showToast('Quote deleted successfully', 'success');
          } catch (err) {
            console.error("Delete quote failed:", err);
            showToast('Failed to delete quote:\n' + err.message, 'error');
          }
        }
        else if (action === 'schedule-visit') {
          if (currentMenu) currentMenu.classList.remove('show');
          showScheduleModal(card);
        }
        else if (action === 'resend-quote') {
          if (currentMenu) currentMenu.classList.remove('show');
          // Resend Quote uses the same flow as Send Quote
          showModal(`
            <h2 class="modal-title">Resend Quote</h2>
            <p style="margin-bottom:20px; color:#4b5563;">Choose how to resend the quote to the client:</p>
            <div class="send-options">
              <button class="btn-modal btn-primary-modal btn-send send-email">Email</button>
              <button class="btn-modal btn-primary-modal btn-send send-sms">SMS</button>
              <button class="btn-modal btn-primary-modal btn-send send-clipboard">Copy to Clipboard</button>
            </div>
            <div class="modal-buttons" style="margin-top:24px;">
              <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
            </div>
          `);
          const resendModalContent = document.getElementById('modalContent');
          resendModalContent.querySelectorAll('.send-email, .send-sms, .send-clipboard').forEach(btn => {
            btn.addEventListener('click', async () => {
              const isEmail = btn.classList.contains('send-email');
              const isSMS = btn.classList.contains('send-sms');
              const isClipboard = btn.classList.contains('send-clipboard');
              
              btn.disabled = true;
              btn.textContent = isEmail ? "Sending..." : (isSMS ? "Sending..." : "Copying...");
              let finalQuoteId = quoteId;
              
              try {
                if (!finalQuoteId || finalQuoteId.trim() === '') {
                  const user = auth.currentUser;
                  if (!user) throw new Error("Not signed in");
                  const token = await user.getIdToken();
                  if (!jobId) throw new Error("No job ID");
                  const jobRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                  });
                  if (!jobRes.ok) throw new Error(`Job fetch failed: ${jobRes.status}`);
                  const jobData = await jobRes.json();
                  const latestQ = jobData.quotes?.length > 0
                    ? jobData.quotes.reduce((a, b) => new Date(a.date) > new Date(b.date) ? a : b)
                    : null;
                  finalQuoteId = latestQ?.id;
                  if (!finalQuoteId) throw new Error("No quote found");
                }
                
                const user = auth.currentUser;
                if (!user) throw new Error("Not signed in");
                const token = await user.getIdToken();
                
                // If email, call the send-email endpoint
                if (isEmail) {
                  const sendRes = await fetch(`${WORKER_URL}/api/quotes/${finalQuoteId}/send-email`, {
                    method: 'POST',
                    headers: {
                      'Authorization': `Bearer ${token}`,
                      'Content-Type': 'application/json'
                    }
                  });
                  if (!sendRes.ok) {
                    let errMsg = await sendRes.text().catch(() => `HTTP ${sendRes.status}`);
                    throw new Error(errMsg);
                  }
                  showToast('Quote email resent successfully!', 'success');
                } else if (isClipboard) {
                  showToast('Quote link copied to clipboard!');
                } else if (isSMS) {
                  // Resend via SMS using the quote_sent template
                  try {
                    let jobData = null;
                    try {
                      const jobRes2 = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, { headers: { 'Authorization': `Bearer ${token}` } });
                      if (jobRes2.ok) jobData = await jobRes2.json();
                    } catch (e) { /* ignore */ }

                    const clientName = (jobData?.client?.firstName || jobData?.client?.name || 'Customer') + (jobData?.client?.lastName ? ` ${jobData.client.lastName}` : '');
                    const clientPhone = jobData?.client?.phone || jobData?.client?.mobile || jobData?.client?.phoneNumber;
                    if (!clientPhone) throw new Error('Client phone number not found');

                    const publicLink = `${window.location.origin}/roof/quote.html?quote=${finalQuoteId}`;

                    let company = { companyName: 'Company', phone: '' };
                    try {
                      const profRes = await fetch(`${WORKER_URL}/api/user/profile`, { headers: { 'Authorization': `Bearer ${token}` } });
                      if (profRes.ok) {
                        const pj = await profRes.json();
                        company.companyName = pj.profile?.companyName || company.companyName;
                        company.phone = pj.profile?.phone || '';
                      }
                    } catch (e) {}

                    const message = window.buildMessageFromTemplate('quote_sent', { clientName, quoteUrl: publicLink, vendorName: company.companyName, vendorNumber: company.phone });
                    window.showSmsModal(clientName, clientPhone, message, { jobId, template: 'quote_sent', vars: { clientName, quoteUrl: publicLink, vendorName: company.companyName, vendorNumber: company.phone } });
                  } catch (e) {
                    console.error('SMS prepare failed', e);
                    showToast('Failed to prepare SMS: ' + (e.message || e), 'error');
                  }
                }
                
                closeModal();
              } catch (err) {
                console.error('[Resend quote failed]', err);
                showToast(`Failed to resend quote:\n${err.message}`, 'error');
              } finally {
                btn.disabled = false;
                btn.textContent = isEmail ? "Email" : (isSMS ? "SMS" : "Copy to Clipboard");
              }
            });
          });
        }
        else if (action === 'send-reminder') {
          if (currentMenu) currentMenu.classList.remove('show');

          // Invoice-specific reminder when job is invoiced
          if (card.dataset.stage === 'invoiced') {
            showModal(`
              <h2 class="modal-title">Send Invoice Reminder</h2>
              <p style="margin-bottom:12px; color:#4b5563;">Select which invoice to send a reminder for:</p>
              <label style="display:block; margin-bottom:8px; font-weight:600;">Invoice</label>
              <select id="modal-invoice-select" class="modal-select"><option value="">Loading...</option></select>
              <p style="margin:16px 0 8px 0; color:#4b5563;">How would you like to send the reminder?</p>
              <div class="send-options">
                <button class="btn-modal btn-primary-modal btn-send send-email">Email</button>
                <button class="btn-modal btn-primary-modal btn-send send-sms">SMS</button>
                <button class="btn-modal btn-primary-modal btn-send send-clipboard">Copy to Clipboard</button>
              </div>
              <div class="modal-buttons" style="margin-top:24px;">
                <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
              </div>
            `);

            const modalContent = document.getElementById('modalContent');
            const invoiceSelect = modalContent.querySelector('#modal-invoice-select');

            (async () => {
              try {
                const token = await auth.currentUser.getIdToken();
                const res = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, { headers: { 'Authorization': `Bearer ${token}` } });
                if (!res.ok) throw new Error('Could not load job invoices');
                const job = await res.json();
                const invoices = job.invoices || [];
                if (invoices.length === 0) {
                  invoiceSelect.innerHTML = '<option value="">No invoices for this job</option>';
                  return;
                }
                invoiceSelect.innerHTML = '<option value="">-- Select invoice --</option>' + invoices.map(i => `<option value="${i.id}">${i.number || i.id} ‚Ä¢ ${i.date} ‚Ä¢ $${(i.total||0).toFixed(2)}</option>`).join('');
              } catch (e) {
                console.error('Failed to load invoices', e);
                invoiceSelect.innerHTML = '<option value="">Error loading invoices</option>';
              }
            })();

            modalContent.querySelectorAll('.send-email, .send-sms, .send-clipboard').forEach(btn => {
              btn.addEventListener('click', async () => {
                const selectedInvoiceId = invoiceSelect.value;
                if (!selectedInvoiceId) return showToast('Please select an invoice first');
                const isEmail = btn.classList.contains('send-email');
                const isSMS = btn.classList.contains('send-sms');
                const isClipboard = btn.classList.contains('send-clipboard');

                btn.disabled = true;
                btn.textContent = isEmail ? 'Sending...' : (isSMS ? 'Sending...' : 'Copying...');

                try {
                  const user = auth.currentUser;
                  if (!user) throw new Error('Not signed in');
                  const token = await user.getIdToken();

                  if (isEmail) {
                    const res = await fetch(`${WORKER_URL}/api/invoices/${selectedInvoiceId}/send-email`, {
                      method: 'POST',
                      headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }
                    });
                    if (!res.ok) {
                      const txt = await res.text().catch(() => `HTTP ${res.status}`);
                      throw new Error(txt);
                    }
                    showToast('Invoice reminder email sent successfully!', 'success');
                  } else if (isClipboard) {
                    const link = `${window.location.origin}/roof/invoice.html?inv=${selectedInvoiceId}`;
                    try { await navigator.clipboard.writeText(link); showToast('Invoice link copied to clipboard'); } catch { showToast('Failed to copy to clipboard', 'error'); }
                  } else if (isSMS) {
                    const tkn = await auth.currentUser.getIdToken();
                    let jobData = null;
                    try { const jobRes2 = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, { headers: { 'Authorization': `Bearer ${tkn}` } }); if (jobRes2.ok) jobData = await jobRes2.json(); } catch (e) {}
                    const clientPhone = jobData?.client?.phone || jobData?.client?.mobile || jobData?.client?.phoneNumber;
                    if (!clientPhone) { showToast('Client phone not found'); }
                    else {
                      const invoiceObj = (jobData?.invoices || []).find(i => i.id === selectedInvoiceId) || null;
                      const amount = invoiceObj ? `$${Number(invoiceObj.total||0).toFixed(2)}` : '';
                      const publicLink = `${window.location.origin}/roof/invoice.html?inv=${selectedInvoiceId}`;
                      let vendorName = 'Company', vendorNumber = '';
                      try { const profRes = await fetch(`${WORKER_URL}/api/user/profile`, { headers: { 'Authorization': `Bearer ${tkn}` } }); if (profRes.ok) { const pj = await profRes.json(); vendorName = pj.profile?.companyName || vendorName; vendorNumber = pj.profile?.phone || vendorNumber; } } catch (e) {}

                      const message = window.buildMessageFromTemplate('invoice_reminder', { clientName: (jobData?.client?.firstName||'Customer'), invoiceUrl: publicLink, amount, vendorName, vendorNumber });
                      window.showSmsModal(jobData?.client?.firstName || 'Customer', clientPhone, message, { invoiceId: selectedInvoiceId, template: 'invoice_reminder', vars: { clientName: (jobData?.client?.firstName||'Customer'), invoiceUrl: publicLink, amount, vendorName, vendorNumber } });
                    }
                  }
                  closeModal();
                } catch (err) {
                  console.error('Invoice reminder failed', err);
                  showToast('Failed to send invoice reminder:\n' + (err.message || err, 'error'));
                } finally {
                  btn.disabled = false;
                  btn.textContent = isEmail ? 'Email' : (isSMS ? 'SMS' : 'Copy to Clipboard');
                }
              });
            });
            return;
          }

          // Fallback to existing quote reminder flow
          showModal(`
            <h2 class="modal-title">Send Reminder</h2>
            <p style="margin-bottom:20px; color:#4b5563;">Choose how to send the reminder to the client:</p>
            <div class="send-options">
              <button class="btn-modal btn-primary-modal btn-send send-email">Email</button>
              <button class="btn-modal btn-primary-modal btn-send send-sms">SMS</button>
              <button class="btn-modal btn-primary-modal btn-send send-clipboard">Copy to Clipboard</button>
            </div>
            <div class="modal-buttons" style="margin-top:24px;">
              <button class="btn-modal btn-cancel" onclick="closeModal()">Cancel</button>
            </div>
          `);
          const reminderModalContent = document.getElementById('modalContent');
          reminderModalContent.querySelectorAll('.send-email, .send-sms, .send-clipboard').forEach(btn => {
            btn.addEventListener('click', async () => {
              const isEmail = btn.classList.contains('send-email');
              const isSMS = btn.classList.contains('send-sms');
              const isClipboard = btn.classList.contains('send-clipboard');
              
              btn.disabled = true;
              btn.textContent = isEmail ? "Sending..." : (isSMS ? "Sending..." : "Copying...");
              
              try {
                const user = auth.currentUser;
                if (!user) throw new Error("Not signed in");
                const token = await user.getIdToken();
                
                if (isEmail) {
                  const reminderRes = await fetch(`${WORKER_URL}/api/quotes/${quoteId}/send-reminder-email`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' } });
                  if (!reminderRes.ok) { let errMsg = await reminderRes.text().catch(() => `HTTP ${reminderRes.status}`); throw new Error(errMsg); }
                  showToast('Reminder email sent successfully!', 'success');
                } else if (isClipboard) {
                  const reminderLink = `${window.location.origin}/roof/quote.html?quote=${quoteId}`;
                  navigator.clipboard.writeText(reminderLink).then(() => { showToast('Reminder link copied to clipboard!'); }).catch(() => { showToast('Failed to copy to clipboard', 'error'); });
                } else if (isSMS) {
                  try {
                    let jobData = null;
                    try { const jobRes2 = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, { headers: { 'Authorization': `Bearer ${token}` } }); if (jobRes2.ok) jobData = await jobRes2.json(); } catch (e) { }
                    const clientName = (jobData?.client?.firstName || jobData?.client?.name || 'Customer') + (jobData?.client?.lastName ? ` ${jobData.client.lastName}` : '');
                    const clientPhone = jobData?.client?.phone || jobData?.client?.mobile || jobData?.client?.phoneNumber;
                    if (!clientPhone) throw new Error('Client phone number not found');
                    const publicLink = `${window.location.origin}/roof/quote.html?quote=${quoteId}`;
                    let company = { companyName: 'Company', phone: '' };
                    try { const profRes = await fetch(`${WORKER_URL}/api/user/profile`, { headers: { 'Authorization': `Bearer ${token}` } }); if (profRes.ok) { const pj = await profRes.json(); company.companyName = pj.profile?.companyName || company.companyName; company.phone = pj.profile?.phone || ''; } } catch (e) {}
                    const message = window.buildMessageFromTemplate('quote_reminder', { clientName, quoteUrl: publicLink, vendorName: company.companyName, vendorNumber: company.phone });
                    window.showSmsModal(clientName, clientPhone, message, { jobId, template: 'quote_reminder', vars: { clientName, quoteUrl: publicLink, vendorName: company.companyName, vendorNumber: company.phone } });
                  } catch (e) { console.error('SMS prepare failed', e); showToast('Failed to prepare SMS: ' + (e.message || e), 'error'); }
                }
                closeModal();
              } catch (err) {
                console.error('[Send reminder failed]', err);
                showToast(`Failed to send reminder:\n${err.message}`, 'error');
              } finally {
                btn.disabled = false;
                btn.textContent = isEmail ? "Email" : (isSMS ? "SMS" : "Copy to Clipboard");
              }
            });
          });
        }
        if (currentMenu) currentMenu.classList.remove('show');
      });
    });

    // 5. Notes section - click to expand/edit
    const notesPreview = card.querySelector('.notes-preview');
    const notesExpanded = card.querySelector('.notes-expanded');
    const saveNotesBtn = card.querySelector('.btn-save-notes');
    const cancelNotesBtn = card.querySelector('.btn-cancel-notes');
    const notesTextarea = card.querySelector('.notes-textarea');
    const jobId = card.getAttribute('data-job-id');

    if (notesPreview && notesExpanded) {
      notesPreview.addEventListener('click', () => {
        notesExpanded.classList.add('open');
        notesPreview.style.display = 'none';
        notesTextarea?.focus();
      });

      cancelNotesBtn?.addEventListener('click', () => {
        notesExpanded.classList.remove('open');
        notesPreview.style.display = 'block';
      });

      saveNotesBtn?.addEventListener('click', async () => {
        try {
          const notes = notesTextarea?.value || '';
          const user = auth.currentUser;
          if (!user) throw new Error("Not signed in");
          const token = await user.getIdToken();
          
          const patchRes = await fetch(`${WORKER_URL}/api/jobs/${jobId}`, {
            method: 'PATCH',
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              jobNotes: notes,
              updatedAt: new Date().toISOString()
            })
          });

          if (!patchRes.ok) {
            const errData = await patchRes.json().catch(() => ({}));
            throw new Error(errData.error || `Update failed (${patchRes.status})`);
          }

          // Update the preview text
          const preview = notes ? notes.substring(0, 120) + (notes.length > 120 ? "..." : "") : "No notes added yet";
          notesPreview.innerHTML = `<b>NOTES:</b> ${preview}`;
          
          notesExpanded.classList.remove('open');
          notesPreview.style.display = 'block';
          showToast('Notes saved successfully!', 'success');
          loadAndRenderJobs();
        } catch (err) {
          console.error("Save notes failed:", err);
          showToast('Failed to save notes:\n' + err.message, 'error');
        }
      });
    }

    // 6. Activity log section - click to expand
    const activityButton = card.querySelector('.last-activity');
    const activityExpanded = card.querySelector('.activity-expanded');

    if (activityButton && activityExpanded) {
      activityButton.addEventListener('click', (e) => {
        e.stopPropagation();
        activityExpanded.classList.toggle('open');
      });
    }
  });
  // Close menus when clicking anywhere outside
  document.addEventListener('click', e => {
    if (!e.target.closest('.overflow') && !e.target.closest('.menu')) {
      document.querySelectorAll('.menu.show').forEach(m => m.classList.remove('show'));
    }
  });
}
// ‚îÄ‚îÄ Start ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.addEventListener('DOMContentLoaded', async () => {
  // Load mock data on page load
  try {
    const response = await fetch('./mock_jobs.json');
    mockJobsData = await response.json();
  } catch (err) {
    console.warn('Failed to load mock_jobs.json:', err);
  }

  // Mock data loading button handler
  document.getElementById('load-mock-data-btn').addEventListener('click', async (e) => {
    e.preventDefault();
    await loadAndRenderJobs(true);
    // Hide loading splash if visible
    const loadingSplash = document.getElementById('loading-splash');
    if (loadingSplash) {
      loadingSplash.classList.add('fade-out');
      setTimeout(() => loadingSplash.style.display = 'none', 500);
    }
  });

  auth.onAuthStateChanged(async (user) => {
    if (user) {
      // Load the jobs (make sure loadAndRenderJobs is awaited if it's async)
      await loadAndRenderJobs(); // ‚Üê add await if your function returns a Promise
      
      // Start periodic sync to catch any data drift
      startPeriodicSync();
      
      // Hide loading splash screen
      const loadingSplash = document.getElementById('loading-splash');
      if (loadingSplash) {
        loadingSplash.classList.add('fade-out');
        setTimeout(() => loadingSplash.style.display = 'none', 500);
      }
      
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // After jobs are loaded and rendered ‚Üí check URL for ?jobId=...
      // and scroll + highlight the matching job card
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const urlParams = new URLSearchParams(window.location.search);
      const targetJobId = urlParams.get('jobId');
      if (targetJobId) {
        const targetCard = document.querySelector(
          `.job-card[data-job-id="${targetJobId}"]`
        );
        if (targetCard) {
          // Smooth scroll to center the card in the viewport
          targetCard.scrollIntoView({
            behavior: 'smooth',
            block: 'center'
          });
          // Optional: brief visual highlight so user immediately sees "this is the one"
          targetCard.style.transition = 'all 0.8s ease';
          targetCard.style.boxShadow = '0 0 0 4px #7c3aed88'; // purple glow
          targetCard.style.backgroundColor = '#f0f9ff'; // light blue tint
          // Remove the highlight after ~3 seconds
          setTimeout(() => {
            targetCard.style.boxShadow = '';
            targetCard.style.backgroundColor = '';
          }, 3000);
        } else {
          console.warn(`Could not find job card with ID: ${targetJobId}`);
        }
        // Optional: clean up the URL so it doesn't keep the ?jobId param forever
        // (doesn't reload the page)
        window.history.replaceState({}, document.title, window.location.pathname);
      }
    } else {
      document.getElementById('jobs-container').innerHTML = `
        <div style="text-align:center; padding:60px;">
          <p style="color:#6b7280; margin-bottom:20px;">Please sign in to view your jobs</p>
          <button onclick="loadAndRenderJobs(true)" style="background: #8b5cf6; color: white; border: none; padding: 12px 24px; border-radius: 10px; font-weight: 600; font-size: 0.98rem; cursor: pointer; box-shadow: 0 2px 8px rgba(139,92,246,0.2);">
            üìã Load Mock Data (Test)
          </button>
        </div>
      `;
    }
  });
  // Keep your existing modal close listener
  document.getElementById('modalOverlay').addEventListener('click', e => {
    if (e.target === e.currentTarget) closeModal();
  });
  // Keep your mini-status class addition (if still needed)
  const miniStatuses = document.querySelectorAll('.mini-status');
  miniStatuses.forEach(status => {
    const text = status.textContent.toLowerCase().replace(' ', '-');
    status.classList.add(`status-${text}`);
  });
  
  // Setup route button hover effects and click handler (handles dynamically added buttons)
  document.addEventListener('click', (e) => {
    if (e.target.id === 'route-apple-maps-btn-today') {
      const todayContainer = document.querySelector('.today-previews');
      // Find the Admin heading to know where on-site jobs end
      const adminHeading = Array.from(todayContainer.querySelectorAll('h3')).find(h => h.textContent.includes('Admin'));
      // Get all mini-cards and filter only those before the Admin section
      let addresses = [];
      const allCards = Array.from(todayContainer.querySelectorAll('.mini-card'));
      for (const card of allCards) {
        // Break if we've reached the admin section (admin heading comes before this card in document order)
        if (adminHeading && !(card.compareDocumentPosition(adminHeading) & Node.DOCUMENT_POSITION_FOLLOWING)) {
          break; // Admin heading is before or contains this card, so we're in admin section
        }
        const addressLine = card.querySelector('.mini-address-line');
        if (addressLine) {
          const addr = addressLine.textContent.trim();
          if (addr && addr !== 'No address') {
            addresses.push(addr);
          }
        }
      }
      
      if (addresses.length === 0) {
        showToast('No on-site jobs to route');
        return;
      }
      
      // Build Apple Maps URL with waypoint format
      let mapsUrl = 'https://maps.apple.com/directions?dirflg=d';
      
      if (addresses.length === 1) {
        // Single address - just set as destination
        mapsUrl += `&destination=${encodeURIComponent(addresses[0])}`;
      } else {
        // Multiple addresses - all except last are waypoints, last is destination
        for (let i = 0; i < addresses.length - 1; i++) {
          mapsUrl += `&waypoint=${encodeURIComponent(addresses[i])}`;
        }
        mapsUrl += `&destination=${encodeURIComponent(addresses[addresses.length - 1])}`;
      }
      
      // Open in new tab
      window.open(mapsUrl, '_blank');
    }
  });

  // Navigation functions
  function toggleMobileMenu() {
    const mobileMenu = document.getElementById('mobileMenu');
    mobileMenu.classList.toggle('open');
  }

  function closeMobileMenu() {
    const mobileMenu = document.getElementById('mobileMenu');
    mobileMenu.classList.remove('open');
  }

  // Close mobile menu when clicking outside
  document.addEventListener('click', (e) => {
    const mobileMenu = document.getElementById('mobileMenu');
    const mobileMenuBtn = document.getElementById('mobileMenuBtn');
    if (!mobileMenu.contains(e.target) && !mobileMenuBtn.contains(e.target)) {
      closeMobileMenu();
    }
  });

  // Scroll effect on navigation
  window.addEventListener('scroll', () => {
    const nav = document.getElementById('mainNav');
    if (window.scrollY > 50) {
      nav.classList.add('scrolled');
      nav.classList.remove('not-scrolled');
    } else {
      nav.classList.remove('scrolled');
      nav.classList.add('not-scrolled');
    }
  });

  // Sign out function
  function signOut() {
    if (confirm('Are you sure you want to sign out?')) {
      // Clear any stored auth data
      localStorage.clear();
      sessionStorage.clear();
      // Redirect to login
      window.location.href = 'login.html';
    }
  }
});
</script>
</body>
</html>